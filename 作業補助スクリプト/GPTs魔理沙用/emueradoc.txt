
evilmask.gitlab.io
用語集 - Emuera.EM+EE ドキュメント
4–5 分
用語集¶

当Wikiでの用語のまとめです。
Emueraの拡張に伴い独自の造語が増えてきたので覚え書きとして記述してみました。
起動モード¶
通常モード¶

Emueraを普通に起動したときのモードです。
EmueraXXXX.exeをダブルクリックして起動したときにこのモードになります。
解析モード¶

コマンドライン引数に解析したいファイル名を渡して起動したときのモードです。
EmueraXXXX.exeにファイルをドラッグ＆ドロップして起動した場合にこのモードになります。
解析モードではドラッグ＆ドロップしたファイルの文法チェックが行われます。
そのため開発中のファイルの文法間違いなどを確認できます。
ただし要素の文字列による指定のチェックのため、使用する予定のバリアントのCSVフォルダが必要になります。
使用する予定のバリアントのEmueraXXXX.exeにファイルをドラッグ＆ドロップすればいいでしょう。
なお、1738gより解析モードのときに「ロード時にレポートを表示する」が有効になっている場合、
読み込まれたERBファイルごとにその中で使われている関数のリストを表示するようになりました。
関数が多すぎてログが流れてしまう場合は、コンフィグでログの行数を増やしてください。
デバッグモード¶

コマンドライン引数に-Debugを渡して起動したときのモードです。詳しくはデバッグモードをご覧ください。
ウインドウ・ダイアログ¶
メインウインドウ¶

通常起動時に最初に開くウインドウのことです。
メインコンソール¶

メインウインドウのうち、特に入出力を行う部分の名称です。
デバッグウインドウ¶

デバッグモードで起動したときに開くことが出来るウインドウのことです。
デバッグコンソール¶

デバッグウインドウで「コンソール」タブを選択したときに表示される入出力を行う部分の名称です。
設定ダイアログ¶

メインウインドウのメニューのヘルプ、設定から開くダイアログのことです。
クリップボードダイアログ¶

メインコンソールからCtrl+Cで開くダイアログのことです。
関数¶
命令¶

PRINTやWAITなどのことです。
関数¶

ERBスクリプト中で@～～文で名称を定義してCALL命令などで呼び出すもののことです。
式中で使える関数のうち、@～～文で名称を定義するものを含みます。
イベント関数¶

関数のうち、関数名がEVENTで始まりシステムから呼び出されるもののことです。
複数定義すれば全てが呼ばれます。
プリプロセッサ¶

ERBフォルダ内のファイルにおいて、他の命令より先に処理をする行のことです。
#で始まる行、もしくは[]で括られた語句からなる行がそれです。
#で始まる行は、属性や定義に分けられます。詳しくはそちらを参照してください。
[]で括られた語句からなる行は、特殊なブロックを表すものです。
詳しくはこちらのページを参照してください。
属性（プリプロセッサ）¶

関数に指定する#で始まる行で、関数の仕様や動作を決定するプリプロセッサです。
イベント関数の実行時の挙動を制御するための#PRI,#LATER,#SINGLE,#ONLY,
式中関数の種別を指定するための#FUNCTION,#FUNCTIONSがあります。
定義（プリプロセッサ）¶

#で始まる行で、変数の名前やその仕様を定義するプリプロセッサです。
関数に指定するものにはLOCAL,LOCALS変数の要素数を指定するための#LOCALSIZE,#LOCALSSIZE,
変数を定義するための#DIM,#DIMS,　ERH中でDEFINEマクロを定義するための#DEFINEがあります。
式中で使える関数¶

式中から呼び出せる「関数」です。
「関数」には上記の関数だけでなく、後述する組み込み関数を含みます。
多くのプログラミング言語では単に「関数」と呼ばれるものです。
式中関数¶

式中で使える関数の略称です。
プログラミング言語における式中関数（匿名関数）やインライン関数とは無関係です。
組み込み関数¶

式中関数のうち、Emueraにもともと組み込まれていて@～～文による定義なしで使えるものです。
ABS(X)やGETTIME()などのことです。
ややこしいですが、上記の関数の定義には該当しません。
「式中で使える命令」と考えるとわかりやすいかもしれません。
ユーザー定義関数¶

ユーザーが定義した関数のことです。
ERBスクリプト中で@～～文で名称を定義してCALL命令などで呼び出すもののことです。
つまり上記の関数と同じ概念です。
#FUNCTION(S)関数¶

@～～文で名称を定義し、#FUNCTION(S)属性を持つものです。
関数かつ式中関数である関数です。
行・文・式¶
行¶

改行コードから次の改行コードまでのことです。
プログラミング関連では物理行とも呼ばれます。
ややこしいことにエディター関係ではこれを論理行と呼ぶことが多いです。
文¶

文あるいは論理行はEmueraにおける1つの処理単位です。
多くの文は、命令1つとその引数、あるいは変数と代入演算子と式からなります。
ERBでは1行につき1文という鉄則のため、行と文はほぼ同じ意味です。
当Wikiでも特に区別しません。
式¶

変数、定数、式中関数、非代入演算子、括弧とその組み合わせです。
代入演算子は代入文の最初の演算子としてのみ使用可能で式中では使えません。
数式¶

式の評価結果（演算結果）が数値になる式です。
例えば、A+B、STR == "あいう"などです。
文字列式¶

式の評価結果（演算結果）が文字列になる式です。
例えば、STR + STR:1、"あ" * 10などです。
変数¶
擬似変数¶

RANDやCHARANUMのように変数のように記述できるが実態は変数ではないものです。
内部の動作としては式中関数に近い動きをしています。
配列変数¶

複数の要素を持つ変数です。
配列変数の要素数はVariableSize.csvで変更でき、通常はスクリプト中では増減しませんが、
一部ローカル変数については、スクリプト中で配列要素数を指定できます。
キャラクタ変数¶

キャラクタの状態を記録する変数です。
C言語などのchar型変数とは無関係です。
その性質上、ADDCHARAやDELCHARAによるキャラの増減に伴い、要素数が増減します。
NO:TARGETなど、配列変数と同じ形式で要素を指定するためにeramakerの解説では配列変数の一つと扱われていますが、当Wikiではキャラクタ変数と配列変数とを区別しています。
二重配列変数¶

キャラクタ変数かつ、配列変数である変数のことです。
CFLAG:TARGET:2のように、2つの引数をとります（省略可）。
キャラクタ変数なので第一引数はキャラNoを表わします。
また、キャラの増減に伴い第一次元の要素数が増減します。
第二次元の要素数はVariableSize.csvでのみ変更でき、スクリプト中では増減しません。

当Wikiではeramakerの仕様の説明を除き、二重配列という用語を使用しません。
代わりにキャラクタ変数かつ配列変数のような呼び方をします。
多次元配列変数¶

DITEMYTPEなどの二次元配列変数及びTAなどの三次元配列変数のことです。
DA:0:1やTA:1:2:3のように2つまたは3つの引数をとります。
多次元配列変数の要素数はVariableSize.csvでのみ変更でき、スクリプト中で増減しません。
また、多次元配列変数の引数は省略できません。
キャラクタ多次元配列変数¶

キャラクタ変数かつ、多次元配列変数である変数のことです。
CFLAG:TARGET:0:2のように、3つの引数をとります（省略不可）。
キャラクタ変数なので第一引数はキャラNoを表わします。
また、キャラの増減に伴い第一次元の要素数が増減します。
第二次元・第三次元の要素数はVariableSize.csvでのみ変更でき、スクリプト中では増減しません。

ver1807現在、この変数に当てはまるものはCDFLAGのみです。
詳しくはCDFLAGをご覧ください。
ローカル変数¶

LOCALやLOCALSやプライベート変数など、関数（関数名）ごとに用意される変数です。
プライベート変数については別項を参照してください。
プライベート変数以外のLOCALやLOCALSに関しては、実際にはいわゆるローカル変数ではなく、
LOCAL@関数名やLOCALS@関数名という名のpublic staticな変数です。
関数を抜けても値は保持され関数の外からでも代入、参照できてしまいます。
また、再帰呼び出しのように複数回呼んだ場合にも値が共有されてしまいます。
広域変数¶

LOCALやLOCALSやプライベート変数などを除くほとんどの変数が属する、すべての関数で値が共有の変数です。
一般的なプログラミング言語におけるグローバル変数の概念ともいえます。
また、ERH中で#DIMもしくは#DIMSを用いることで広域変数を定義することができます。
詳しくはヘッダーファイル（ERH）のページを参照してください。
グローバル変数¶

異なるセーブデータ間で値を共有することができる変数です。グローバル変数も広域変数に含まれます。
通常の変数とはセーブロードや初期化のタイミングが異なります。
Emueraのグローバル変数はこれは一般的なプログラミング言語におけるグローバル変数の概念とは無関係です。
プライベート変数¶

関数（関数名）ごとに#DIMもしくは#DIMSによって定義される変数です。
これらもローカル変数でありますので、関数ごとに別個のものです。
ただし、同じローカル変数とされているLOCALなどとは異なり、@関数名などを使っての関数の外からの代入、参照はできません。
詳しくはユーザー定義の変数のページを参照してください。


evilmask.gitlab.io
デバッグコマンド - Emuera.EM+EE ドキュメント
1–2 分
デバッグコマンド¶

※標準ではデバッグコマンドは使用できません。
必要ならヘルプの設定からデバッグコマンドを使用するにチェックを入れてください。

※この機能はデバッグモードが無かったバージョンの簡易的な機能です。
現バージョンでのデバッグにはデバッグモードでの起動を勧めます。

スクリプト実行中（ゲーム中）、@で始まる文字列を入力するとデバッグコマンドとして受け付けられます。
大文字小文字を区別するかどうかはemuera.config中の大文字小文字の違いを無視するの指定に依存します。

デバッグコマンドはERBと同じ書式で指定します。
例えば、

@MONEY = 10000
@PRINTV FLAG:200
@PRINTFORM %NAME:MASTER%のCFAG(1) = {CFLAG:MASTER:1}
@ADDCHARA 1

のように書くことができます。
また、単に変数や数式を入力した場合、それらの値が出力されます
（下記の@の後の半角スペースは必須ではありません）

@ FLAG:200
@ @"%NAME:MASTER%のCFAG(1) = {CFLAG:MASTER:1}"

ただし[IF](../Reference/IF.md)や[CALL](../Reference/CALL.md)のようなスクリプトの流れを変える命令や、[INPUT](../Reference/INPUT.md)や[WAIT](../Reference/WAIT.md)のように入力を要求する命令は使えません。

いくつかのERBにはない命令があります。

@REBOOT

再起動してemuera.configやcsv、erbファイルを読み直します。

@OUTPUT

現在のログをemuera.logに出力します。既に存在する場合は上書きされます。
これはOUTPUTLOG命令と同じ動作です。

@EXIT

Emueraを終了します。[QUIT](../Reference/QUIT.md)命令と同じ動作です。

@CONFIG

設定ダイアログを開きます。

@DEBUG

デバッグダイアログを開きます。これはデバッグモードで起動した場合のみ有効です。

上記以外、つまり通常のERBの命令を実行した場合、MASTERの名前・呼び名が強制的にイカサマになります。
これはデバッグコマンドがチートとしての性質も持つため、乱用を防ぐための措置です。


evilmask.gitlab.io
デバッグモード - Emuera.EM+EE ドキュメント
~3 分
デバッグモード¶

デバッグモードはver 1.750で追加されたモードです。
この機能はデバッグコマンドを使用するオプションとは無関係です。

Emueraをデバッグモードで起動するにはコマンドライン引数に-Debugを渡します。

コマンドライン引数を渡す簡単な方法は、
EmueraXXXX.exeを右クリックし、ショートカットの作成を選択、
作成されたショートカットを右クリックし、プロパティを選択、
プロパティでリンク先の文字列の末尾に-Debugを加えます。
(リンク先が"C:\～～\EmueraXXX.exe"のように""で囲まれている場合、"の後に-Debugを加えてください)
ショートカットをダブルクリックするとデバッグモードで起動するようになります。
デバッグモード時の動作¶

デバッグモードで起動するとdebugというフォルダが自動的に作成されます。
後述する変数ウォッチのリストやデバッグコンソールのログはdebugフォルダに保存されます。

デバッグモード時には通常実行される行に加え、;#;で始まる行、[IF_DEBUG]～[ENDIF]の間の行が実行されます。
デバッグモードでないときはこれらの行はコメントと同様に扱われ、実行されません。
逆にデバッグモード時には、[IF_NDEBUG]～[ENDIF]の間の行はコメントして扱われ、実行されません。

    ;#;PRINTL この行はデバッグモード時のみ実行されます。
[IF_DEBUG]
    PRINTL この行はデバッグモード時のみ実行されます。
[ENDIF]
[IF_NDEBUG]
    PRINTL この行はデバッグモードでないときのみ実行されます。
[ENDIF]

また、デバッグモード時にのみ機能する命令があります。
DEBUGPRINT、DEBUGPRINTFORM、DEBUGPRINTL、DEBUGPRINTFORMLの命令は[PRINT](../Reference/PRINT.md)文などと同じ機能を持ちますが、出力先がデバッグウインドウです。
ASSERT命令は引数が0の時、エラーを出します。引数が非0の時は何もしません。
DEBUGCLEAR命令はデバッグウインドウの文字を全て消去します。引数はありません。
これらの命令は非デバッグモード時には何もしません。
引数の解析も行わないのでDEBUGPRINTFORMの書式がおかしいなどの問題があっても非デバッグモード時には何も起きません。
これらは何もしない命令と扱われるだけでコメント行と扱われるわけではないので[SIF](../Reference/IF.md)文の直後に使っても安全です。

また、変数__FILE__, __LINE__, __FUNCTION__はデバッグ時のみ意味のある値を返します。
非デバッグモード時には0又は空文字列を返します。
デバッグウインドウ¶

デバッグモード時にはデバッグウインドウを開くことが出来ます
メニューのデバッグから開くか、コンソールで@DEBUGと入力して下さい。
また、メインコンソールでショートカットキーCtrl+Dでもデバッグウインドウを開くことが出来ます。
コンフィグオプションによっては起動時にデバッグウインドウが自動で開きます。

デバッグウインドウはサイズ可変です。用途に合わせてサイズを変えてください。
デバッグウインドウの初期サイズ、初期位置は設定ダイアログのデバッグの項目から変更できます。
デバッグウインドウを開いた状態で設定ダイアログを開くと現在のサイズ、位置を取得できます

デバッグウインドウに表示される情報はデバッグウインドウ内のタブによって切り替えることができます。
情報はデバッグウインドウがフォーカスを得た時やタブを切り替えた時などに更新されます。
また、メインコンソールからショートカットキーCtrl+Rで情報を更新できるほか、
DEBUGCLEAR命令によって文字を全て消去することもできます。
コンソール¶

デバッグ用のコンソールです。
DEBUGPRINTやDEBUGPRINTFORMなどの出力先です。
また、メインコンソールに出力される情報のうち、エラーや警告などはデバッグコンソールにも出力されます。
コンソールの一番下のテキストボックスからはデバッグコマンドを入力できます。
メインコンソールでのデバッグコマンドと異なり、先頭に@をつける必要はありません。
この機能はデバッグコマンドを使用するオプションがNOの場合でも有効です。
また、MASTERの名前がイカサマになることはありません。
変数ウォッチ¶

対象と書かれたカラムの下辺りをクリックしてください。編集モードになるはずです。
ここにTALENT:MASTER:2、NAME:TARGETなど値を知りたい変数名を入力すると値の項に値が表示されます。
値取得中にエラーが発生した場合にはエラーの内容が表示されます。
対象を削除したい場合、対象を編集し空文字列にしてください。
変数ウォッチが更新されるタイミングでその行が削除されます。
変数ウォッチに追加した対象はデバッグウインドウを閉じた時に保存され、開く時に読み込まれます。
それ以外のタイミングで保存・読込をしたい場合にはメニューのファイルから保存・読込をしてください。

対象として変数だけでなく定数や式も利用できますが、式中関数を呼び出す場合には注意してください。 変数ウォッチは値を更新するたびにその式中関数を実際に呼び出しています。 呼び出された式中関数に他の変数を変えるなどの副作用がある場合、変数ウォッチが更新されるたびに副作用が起きます。
スタックトレース¶

呼び出し中の関数の情報です。
一番上が現在の関数で、以下に現在の関数を呼び出した関数、その関数を呼び出した関数と続きます。


evilmask.gitlab.io
_replace.csv - Emuera.EM+EE ドキュメント
2–3 分

csvフォルダ内に_replace.csvという名称のファイルを置くことで、表示に関する設定を行うことができます。
お金の単位¶

PRINT_SHOPITEMで表示されるアイテムの価格に付けられる単位です。
標準は$です。全角文字や複数の文字を含む文字列でもかまいません。
単位の位置¶

PRINT_SHOPITEMで表示されるアイテムの価格に付けられる単位が数字の前に付くか後ろに付くかです。
前か後で指定します。標準は後です。
起動時簡略表示¶

コンフィグでロード時にレポートを表示する機能をOFFにした場合に代わりに表示する文字列です。
標準はNow Loading...です。
販売アイテム数¶

eramakerの通常のSHOPの処理において、PRINT_SHOPITEMではITEMSALESが0でないITEMNAME(0～999)が全て表示されます。
一方で、購入処理と@EVENTBUYの処理が行われるのは0～99が入力された場合のみで、その他の値が入力された場合は@USERSHOPが呼ばれます。

Emueraも基本的にはこの処理を再現しています。
販売アイテム数を変更すると、購入処理が呼ばれるアイテムの範囲が変化します。
例えば、販売アイテム数を1000にすると、0～999が入力された場合は購入処理が行われ、負の値か1000以上の値が入力された場合は@USERSHOPが呼ばれます。

0～(販売アイテム数-1)が入力された場合は購入の成否にかかわらず、@USERSHOPが呼ばれないことに気を付けて下さい。
例えば販売アイテム数が1000であれば、"[200] - セーブ"や"[300] - ロード"は200番、300番のアイテムを買おうとする処理とみなされ、@USERSHOPは呼ばれません。

なお、PRINT_SHOPITEMで表示するアイテムを増やしたい（減らしたい）場合はVariableSize.csvのITEMNAMEおよびITEMSALESの配列の要素数を変えてください。
ITEMNAMEとITEMSALESの配列の要素数のうち、小さい方がPRINT_SHOPITEMで表示されるアイテムの範囲になります。
DRAWLINE文字¶

[DRAWLINE](../Reference/DRAWLINE.md)命令で表示される文字です。
標準では-です。
BAR文字1¶
BAR文字2¶

[BAR](../Reference/BAR.md)又は[BARL](../Reference/BAR.md)命令に使われる文字を指定します。
標準はBAR文字1が*であり、BAR文字2が.です。
この場合は[****....]のように表示されます。
全角文字や複数の文字からなる文字列も指定できますが、表示がずれることを考慮してください。
また、数字を指定した場合、Emueraは[88881111]などをクリック可能なボタンとみなすために不自然な動作をすることになります。
システムメニュー0¶
システムメニュー1¶

タイトル画面で最初に表示される選択肢の説明に使われる文字列です。
標準ではそれぞれ最初からはじめる、ロードしてはじめるであり、

[0] 最初からはじめる
[1] ロードしてはじめる

上記のように表示されます。
@SYSTEM_TITLEを定義して独自のタイトル画面を使う場合、ここで指定した文字列は使用されません。
@SYSTEM_TITLEの中で表示処理を作成してください。
COM_ABLE初期値¶

TRAINで@COM_ABLE{X}が見つからない場合の値を指定します。
標準は1であり、対応する@COM_ABLEが定義されていない場合はCOMが実行可能とみなされます。
この値を0にすると、@COM_ABLEが定義されていない場合はCOMが実行不可能とみなされます。
汚れの初期値¶

STAINが初期化されるときに代入される値です。
/で区切ることでSTAIN:1以降の値を指定できます。
標準は0, 0, 2, 1, 8です。
時間切れ表示¶

TINPUTなど時間制限がある入力命令で時間切れの時に表示される文字列です。
標準は時間切れです。
EXPLVの初期値¶

EXPLVの初期値を指定します。
/で区切ることでEXPLV:1以降の値を指定できます。
標準は0, 1, 4, 20, 50, 200です。
PALAMLVの初期値¶

PALAMLVの初期値を指定します。
/で区切ることでPALAMLV:1以降の値を指定できます。
標準は0, 100, 500, 3000, 10000, 30000, 60000, 100000, 150000, 250000です。
PBANDの初期値¶

PBAND:0の初期値を指定します。
標準は4です。
RELATIONの初期値¶

Chara**.csvにおいて、指定がない場合のRELATIONの初期値を指定します。
標準は0です。


evilmask.gitlab.io
コンフィグ設定の強制 - Emuera.EM+EE ドキュメント
~2 分
コンフィグ設定の強制¶

Emueraはcsvフォルダ内に_fixed.config及び/又は_default.configというファイル名のファイルが存在するとこれらのファイルを読みに行きます。
各.configファイルの書式はemuera.configと同じです。 各項目の意味はコンフィグの項目を参照してください。

各ファイルの優先度はEmueraがconfigファイルを読む順序に依存しています。
Emueraがコンフィグファイルを読む順序は

csv¥_default.config
emuera.config
csv¥_fixed.config

の順であり、後から読まれた設定によって上書きされていきます。 すなわち、_default.configの設定はemuera.configによって上書きされ、emuera.configの設定は_fixed.configによって上書きされます。 なお、これらのファイルは上記のパス、ファイル名で存在していないと読み込まれません。 つまり、csvフォルダの中にサブフォルダを作ってその下に_fixed.configや_default.configを置いたり、default.configといったアンダーバーの抜けたファイル名にしたりしても読み込まれることはありません。
_fixed.config¶

_fixed.configに設定されたオプションはemuera.configよりも優先されます。 また、_fixed.configで指定された項目はEmueraの設定ダイアログによって変更できなくなります。 _fixed.configは意図した動作をするために特定のオプションが必須である場合にのみ使用してください。 Emueraの行折り返し位置に依存しているスクリプトではボタンの途中で行を折りかえさないオプションをYESにする必要があります。 また、_Replace.csv・_Rename.csvを利用する必要があればこれらに関するオプションが必須です。 他に、SETCOLORを利用する場合には、背景色・文字色などを固定する必要があるでしょう。 しかし、特に必須でないオプションまで_fixed.configで設定を行うとユーザーによるカスタマイズができなくなってしまいます。 _fixed.configに設定する項目は最小限に留めるようにしてください。
_default.config¶

強制するほどではないけれども推奨したいオプションがある場合は、fixedの代わりに_default.configを使用します。 _default.configはemuera.configが存在しない場合、初期設定として使われます。 emuera.configが存在する場合にはemuera.configで設定したオプションが優先されるので、ユーザーが設定したオプションを上書きすることはありません。


evilmask.gitlab.io
eramakerとの相違点 - Emuera.EM+EE ドキュメント
7–9 分
バグ・不自然な動作の修正¶
配列の最後の要素が使用できない¶

eramakerでは配列の最後の要素が0で無いとロード時にデータが破壊されます。
Emueraではこの問題は起きません。
この問題はeramakerでセーブとロードの仕様が統一されていないことから発生していますが、Emueraはセーブ時の仕様で統一しています。
したがって、eramakerでセーブしEmueraでロードするとこの問題は発生しませんが、Emueraでセーブしeramakerでロードするとこの問題が再現されます。
単項演算子-の異常¶

eramakerでは-100 < 0が偽になるなどの問題があります。
Emueraではこの問題は起きません。
ファイルの最後の行が読まれない¶

eramakerでは改行コードの無い行を無視します。
つまり、CSVでもERBでもファイルの最後の行は無視されます。
Emueraではこの動作を再現しません。
配列に余分な要素がある場合無視される¶

A:1:2 = 34

上の式はeramakerではA:1に34が代入されます。
Emueraはこれをエラーにします。
配列の呼び出しに特定の書式が使えない¶

eramakerではA:0やA:(COUNT+1)といった変数の使い方ができます。
一方で二重配列変数でABL:0:2やTALENT:(COUNT+1):2のような書き方をするとエラーになります。
また文字列変数の呼び出しの際に引数を省略するとエラーになることがあります。
Emueraではこの問題は起きません。
二重配列の引数が定数でも数式でもエラーは起きませんし、文字列変数の引数を省略することができます。
CSV内の異常な数値を整数として扱う¶

0,ローター,200  
0xFF,ルーター,200

上のような記述がItem.csvにあった場合、eramakerは0xFFを0として解釈しTALENT:0はルーターとして定義されます。
Emueraはこれを再現せず、エラーを出した上でこの定義を無効にし、TALENT:0はローターとして定義されます。
不自然な表記が動作する¶

A:0:1:99999 +-RESULTS:0=@=+123|*?=Y

上の式はeramakerでは動作します。
Emueraはこれをエラーにします。
その他eramakerと動作が異なる点¶

SIFの直後が空行・コメント行などである場合

SIF 条件文  
    ;コメント  
    PRINT hogehoge

と言うスクリプトについて、eramakerは常にPRINT行を実行します。
eramakerはSIFの次の行は;コメントであると認識するからです。

Emueraは吉里吉里などと同様に条件文が真である場合のみPRINT行を実行します。
Emueraは空行やコメント行は全く存在しないものとして扱い、SIFの次の行はPRINT hogehogeであると認識します。
また、eramakerではSIFの次の行にIF文やREPEAT文を置くことができますが、これは多くの場合に製作者の意図と異なる動作をするためにEmueraはSIFの次に持ってくる行に制限をかけています。
IF、ELSEIFなどの引数を省略した場合の動作¶

eramakerではIF、ELSEIFや代入文の引数を省略した場合、動作が不定となります。
ただし、RETURNの引数が省略された場合はRETURN 0です。
Emueraは省略された引数は常に0と解釈するので、IF以下は常に実行されませんが、警告対象となります。
関数名に使用可能な文字¶

eramakerでは記号や全角文字など全ての文字が使用可能です。
Emueraでも全角文字は使用できますが、_（アンダーバー）以外の記号は使用できません。
また、Emueraでは関数名を半角数字で始めることを推奨しません。
以下のスクリプトはeramakerでは動作しますが、Emueraではエラーになります。

CALL \.,)(][+-%* 　@&$

@\.,)(][+-%* 　@&$  
PRINTL 関数@\.,)(][+-%* 　@&$が呼ばれた。  
RETURN 0

Emueraでは関数名に,または(を含む場合、関数の引数と誤解されてしまいます。
また、関数名に@や演算子の記号などを含む場合、LOCAL@関数名という呼び出しが正常に機能しません。
{}や%を含む場合、CALLFORMでの呼び出しに支障があります。
そのためEmueraでは、C#や吉里吉里など多くのプログラミング言語と同様に、関数名に記号を使うことを禁止しています。
ver 1.721現在ではこれは警告Lv 1であり直ちにエラー終了するような警告ではありませんが、どこかで意図しない動作をする可能性があります。
また、関数名が半角数字で始っていると式中で使える関数(in_expression_functions.md)として呼び出すことができません。
式中では一文字を見て数字か変数・関数かを判別するためです。
RANDの仕様¶

A = RAND:X

について、eramakerではXが0の時、0を返します。
そうでない場合、(0～32767までの乱数) % (Xの絶対値)を返します。
この方式はXが負の値でも動作する、32767以上の値を返すことが無い、Xが1000を超えるあたりで値の偏りが無視できない、などの特徴があります。

Emueraはこれらを再現しません。
Emueraは(0～18446744073709551615までの乱数) % (X)を返します。
Xが0または負の値の時、Emueraはエラーになります。
（公式の解説にある返されるのはRAND:Aの場合0からA-1までの整数であるとの記載に基づき、戻り値の一貫性を重視した結果です）
また、Xは1～9223372036854775807の範囲(64ビット符号付整数の正の範囲)まで有効です。
Xが100兆程度以下であれば体感できるほどの偏りはありません。
WAITの仕様¶

eramakerではWAIT命令実行時には改行せず、Enterキーを押した時に改行を伴います。
EmueraではWAIT命令実行時にカーソルが行の途中の場合改行を行い、「Enterキーを押した」「左クリックをした」などの時には改行を伴いません。
JUMPの仕様¶

eramakerではCALLで呼ばれた関数からJUMPすることができません。
EmueraではCALLされた関数でもJUMPすることができます。
JUMP先でRETURNするとJUMP元関数でRETURNした時と同じ動作になります。

例

CALL FOOBAR

@FOO  
PRINTL 関数@FOO  
JUMP BAR  
@BAR  
PRINTL 関数@BAR  
RETURN 0  
@FOOBAR  
PRINTL 関数@FOOBAR  
CALL FOO  
PRINTW 関数@FOOBARに戻ってきた

実行結果
eramaker(エラー)

CALLで呼ばれた先からJUMPで関数を呼び出そうとしました

Emuera

関数@FOOBAR  
関数@FOO  
関数@BAR  
関数@FOOBARに戻ってきた

CALLNAMEの仕様¶

eramakerではCALLNAMEを参照したときにCALLNAMEが空文字列の場合、代わりにNAMEの値を返します。
EmueraではCALLNAMEが空文字列ならば空文字列を返します。

この差を埋めるためにEmueraではCALLNAMEが空文字列の時にNAMEを代入するオプションが用意されています。
このオプションがYESのとき、chara*.csvでCALLNAMEが設定されていない又は空文字列に設定されている場合、NAMEと同じ文字列が設定されたものとして扱います。
しかし、このオプションでも完全に再現できるわけではありません。
例えばeramakerでキャラを追加したセーブデータをEmueraで読んだ場合などに動作が異なることが考えられます。
PRINTFORMなどFORMの展開¶

eramakerは展開できるものが無くなるまで何度でも繰り返します。
自己参照や循環参照がある場合、フリーズします。
Emueraは一度だけ展開します。
eramakerの展開はおそらく以下のように行われます。

str = 展開したい文字列  
while(strの中に{～～}がある)  
    一番左の{～～}を展開  
while(strの中に%～～%がある)  
    一番左の%～～%を展開  
while(strの中に***がある)  
    一番左の***を展開  
while(strの中に$$$がある)  
    一番左の$$$を展開  
while(strの中に+++がある)  
    一番左の+++を展開  
while(strの中に///がある)  
    一番左の///を展開  
while(strの中に===がある)  
    一番左の===を展開

この動作のため、eramakerでは以下のようなことも可能です。

例

STR:1 = S1%STR:2%3%4%  
STR:2 = S2%STR:  
STR:3 = S3%STR:  
STR:4 = S4  
PRINTFORMSL STR:1  
PRINTFORML %STR:1%  
DRAWLINE

結果

;S1S2S3S4  
;S1S2S3S4

Emueraはこれを再現しません。
EVENT関数の属性¶

eramakerではイベント関数の呼び出しは以下のように行われています。

foreach(#PRIの付いた関数)  
{  
    関数呼び出し  
    if(#SINGLEかつ返り値が1である)  
        break;  
}  
foreach(#PRIも#LATERも付いていない関数)  
{  
    関数呼び出し  
    if(#SINGLEかつ返り値が1である)  
        break;  
}  
foreach(#LATERの付いた関数)  
{  
    関数呼び出し  
    if(#SINGLEかつ返り値が1である)  
        break;  
}

#PRIと#LATERを両方付けたイベント関数は2回呼ばれます。
#SINGLEは返り値が1のときのみ、以降の関数呼び出しを中断します。
また、#SINGLEによる関数呼び出しの中断は、#PRIや#LATERを付けた組ごとに行われます。
ver1.800(開発版も含めると1.756alpha018)以降のEmueraではこの動作を正確に再現します。

それより前のEmueraではイベント関数の呼び出しは以下のように行われていました。
関数リストを#PRI、#LATERに基づき並び替え

foreach(全ての関数)  
{  
    関数呼び出し  
    if(#SINGLEかつ返り値が1である)  
        break;  
}

#PRIと#LATERを両方付けた場合、どちらも付けていないものと同様に扱われます。
#SINGLEにより関数呼び出しを中断された場合、#PRI、#LATERの有無によらずそのイベント関数の呼び出しは終わりです。

なお、Emuera1.751bまでは#SINGLEは返り値が0でないときに以降の関数呼び出しを中断していました。
これは1.752で修正され、現在のバージョンではeramaker同様に返り値が1のときのみ以降の関数呼び出しを中断します。
gamebase.csv「コード」の読み方¶

gamebase.csvのコードに、eramakerで扱える数である-2147483648～2147483647の範囲を超えた数の値を書いた場合、
eramakerではcsvに書かれた値を16進数に直し、下8桁をゲームコードとして使用します。
たとえばコード,08231000181818110のような場合、ゲームコードは301712126になり、eramakerで扱える範囲になります。

Emueraはこの動作を再現しません。
ver1.803以前のEmueraでは、コード,08231000181818110のような場合、ゲームコードは0になります。
Emueraでは-9223372036854775808～9223372036854775807の範囲の数を扱うことができますが、
GAMEBASE_GAMECODEのみeramaker同様-2147483648～2147483647の範囲の数しか扱わず、その範囲を超えた場合は0になります。

さらに、ver1.804以降のEmueraでは、コード,08231000181818110のような場合もゲームコードは書いた通り8231000181818110となります。
（GAMEBASE_GAMECODEも他の変数と同様の範囲を扱う変数に変更されました）
この場合もコード,98231000181818110110のようにEmueraで扱える数の範囲を超えた数の値の場合、ゲームコードは0になります。
なお、ver1.805以降のEmueraでは、セーブデータのゲームコードが0の場合、ゲーム側のゲームコードに関わらず読み込むことができます。
abl.csvなどの読み方¶

eramakerでは99999:技巧のようにインデックスに負の値や非常に大きい値を指定できます。
ただし、ここで指定した番号はPRINT_ABLなどで使用されるため、PRINT_ABLの際に(eramaker内部で)ABL:99999が参照され、エラーが発生します。
このため、実用的に使える値はABLやTALENTの配列数と同じです。
item.csvでもSHOPでITEMやITEMSALESを参照したときにエラーが発生します。
EmueraではABLなどの配列の範囲外の値を指定できません。
そのような行は無視されます。
その代わり、VariableSize.csvによって配列の範囲を変えることができます。
train.csvの読み方¶

基本的には他のcsvファイルと同じですが、他と少し事情が違います。
eramakerでは例えばXXX,99999という定義をしても、@COM99999が定義されていれば正常に実行されます。
一方、YYY,-2のように負の値を定義すると、コマンドは表示されるものの、選択しても何もおきません。

Emueraはこの動作を再現しません。
定義できる範囲はVariableSize.csvで指定したTRAINNAMEのサイズまでで、それ以外は無視されます。
TRAINNAMEのサイズを変更していなければ、0～999までが有効です。
chara*.csvの読み方¶

eramakerでは番号が0未満や1000以上であっても正常にADDCHARAできます。
これはEmueraでも同じ動作です。

eramakerでは基礎,0のように、3番目の値が必要な場合にそれを省略すると0と扱われます。
また、素質,0,100のように3番目の値が不要な場合に値を指定しても無視され、1になります。
Emueraはこの動作を再現しません。
基礎,0とすればMAXBASE:0は1になり、素質,0,100とすればTALENT:0は100になります。
ファイルの改行コード¶

eramakerでは改行コードが[CR][LF]と[LF]のときを改行としますが、[CR]のみのとき改行とされずさまざまな誤動作が発生します。
Emueraはこの動作を再現せず、[CR]のみの場合も改行とみなします。
修正されていないバグ・不自然な動作¶
ファイル読込順がファイルシステムに依存する¶

eramaker basicでは多重定義された関数をCALLしたときなど、動作がファイルの読込順に依存するケースがあります。
しかし、eramakerではファイルの読込順がファイルシステムに依存するので期待した通りに動かない場合があります。
Emueraでもこの問題が再現されます。
現在公開されている多くのスクリプトはファイルシステムがNTFSであることを前提としており、ファイルシステムがFATの場合は正常に動作しません。
REPEAT-REND終了時にCOUNTが加算される¶

eramakerではREPEAT-RENDを抜けるときにCOUNTが+1されます。
BREAKで抜けた時も+1されます。
Emueraの動作を再現します。
FOR-NEXT構文においても同様にループ変数を+1します。
一般的なプログラム言語のfor構文やbreak文と動作が異なるので注意してください。
NEXTCOMの動作¶

eramakerではNEXTCOMの初期値は-1ですが、NEXTCOMが実行された後に代入される値は-1ではなく0です。
そのため、ERB側で再度代入しない限りCOM0を繰り返し続けることになります。
なお、eramakerの公式の解説にはNEXTCOMの存在は記載されていません。
Emueraもこの動作を再現します。
NEXTCOMの機能はeramakerとの互換性のためにのみ再現しており、使用は推奨されません。
eramakerで動かす予定のないコードであれば、DOTRAINやCALLTRAIN命令の使用を検討してください。
変更された機能¶
SPキャラ¶

eramakerではcsvでCFLAG:0が非0に設定されたキャラクタはSPキャラとなります。
ADDCHARAでは登録できずADDSPCHARAによって登録しなければならないなどややわかりにくい仕様でした。
また、意図せずにCFLAG:0を非0に設定してADDCHARAで登録できなくなってしまうなどバグの原因ともなっていました。
Emueraではver 1.816からこの機能を標準でサポートしないことに決定しました。
CFLAG:0はもはや特別扱いされず、全てのキャラはADDCHARAから登録できるようになりました。
互換性オプション「SPキャラを使用する」によってeramakerの動作を再現することは可能ですが、古いスクリプトを動作させる以外の目的で使用することは推奨しません。



evilmask.gitlab.io
Emueraで追加された記法 - Emuera.EM+EE ドキュメント
6–7 分
行末コメント¶

A = B ;AにBを代入

このように行の末尾にコメントを挿入できます
ただし、一部例外があり、PRINT命令のように引数が単純文字列の命令の場合にはコメント化されず文字列の一部と評価されます

PRINT foobar;ほげほげ

この場合、foobar;ほげほげがPRINTされます
行の連結¶

{  
    DIM CONST HOGE =  
        1,2,3,4  
}

と書くと#DIM CONST HOGE = 1,2,3,4と解釈されます
{、}の行にはホワイトスペース以外の他の文字が存在してはなりません
改行記号のある位置には半角スペースが補われます
つまり関数名・変数名の途中で行を分割することはできないほか、
PRINTなどを分割すると表示文字列の中に改行だった半角スペースが含まれます
Emueraの文法解釈において行連結処理はコメントの解釈より先に行われます
つまり

{  
    #DIM CONST HOGE =  
        1,2,3,4 ;コメント  
        ,5,6,7,8  
}

は#DIM CONST HOGE = 1,2,3,4 ;コメント ,5,6,7,8となり、
`,5,6,7,8は行末コメントの一部とみなされ無視されます
特別なコメント行¶
;!;¶

Emuera、eramakerのいずれでも、;で始まる行はコメント行とみなされますが、Emueraは;!;で始まる行はコメントではなく有効な行とみなします。
eramakerでは実行してほしくない文を記述する際に使ってください。
例えば@SHOWSHOPに以下のスクリプトを加えるとEmueraでの動作を禁止できます。

;!;PRINTW このスクリプトはEmueraでは実行できません  
;!;QUIT

また、[SKIPSTART]や[SKIPEND]と併用することで、以下のスクリプトのようにEmuera以外での動作を禁止できます。
Emuera以外では実行してほしくない文を記述する際に使ってください。

;!;[SKIPSTART]  
PRINTW このスクリプトはEmuera以外では実行できません  
QUIT  
;!;[SKIPEND]

;#;¶

;#;で始まる行はデバッグモード時のみ実行されます。
非デバッグモード時ではコメント行と見なされ実行されません。
ただし、DEBUG系命令は元々非デバッグモード時には無視されるので、;#;を行頭に付ける必要はありません。
同様にデバッグ変数も非デバッグモード時には空文字列又は0のため、エラーの心配はありません。
デバッグモードについてはこちらを参照してください。
キャラクタ配列¶

eramakerではおそらくキャラクタ作成用の配列が100個しか用意されていません。
そのため、chara3.csvとchara03.csvとchara3B.csvでそれぞれ別のキャラを定義しても一人しか有効になりません。
Emueraではキャラクタはメモリが許す限りいくらでも定義できます。
また、chara*.csvに該当すればchara101.csv、charaABC.csvなどどんなファイルでも読みに行きます。
キャラの番号が重複し、ADDCHARA又はADDSPCHARAの際に複数の候補がある場合、先に読み込まれた方のみが有効になります。
整数型の値の範囲¶

eramakerで扱える整数は32ビット符号付整数、すなわち-2147483648～2147483647の範囲です。
Emueraでは吉里吉里と同じく64ビット符号付整数、-9223372036854775808～9223372036854775807の範囲の値を扱います。
配列変数への一括代入¶

A:10 = 1,2,3  
DA:0:0 = 1,2,3

上のように書いた場合、A:10～A:12にそれぞれ1,2,3の値が代入されます
下のような多次元配列では、DA:0:0～DA:0:2にそれぞれ1,2,3の値が代入されます
DA:0:0～DA:0:99の次にDA:1:0に代入することはなく、配列外参照エラーになります
ただし、複合代入演算には使えません（A += 1,2,3などは不可）。
また、文字列型配列変数への代入に一括代入を用いる場合、文字列式を用いた代入を行わなくてはなりません

;STR:20に「いちご,メロン,ブルーハワイ」という文字列が代入される  
STR:20 = いちご,メロン,ブルーハワイ  
;STR:20～STR22にそれぞれ「いちご」「メロン」「ブルーハワイ」が代入される  
STR:20 '= "いちご", "メロン", "ブルーハワイ"

FORM構文を用いた文字列変数への代入¶

文字列変数への代入の際、PRINTFORMと同じ形式で代入する文字列を指定できます。

SAVESTR:0 = %RESULTS%

この文でSAVESTR:0にRESULTSの中身を代入することができます。
同じ文はeramakerではSAVESTR:0に%RESULTS%という文字列そのものを代入したことになります。
Emueraで%RESULTS%という文字列そのものを代入したい場合、以下のように書いてください。

SAVESTR:0 = \%RESULT\%

\記号の直後の文字はシステム記号として扱われません。
\記号自体を文字列に含めたい場合は\\としてください。
あまりないケースですが、eramakerとEmueraで同じ動作をさせたい場合は以下のように書く必要があります。

;!;SAVESTR:0 = \%RESULT\%  
;!;[SKIPSTART]  
SAVESTR:0 = %RESULTS%  
;!;[SKIPEND]

文字列式を用いた文字列変数への代入¶

ver1813以降のEmueraでは新たに、代入演算子'=と文字列式を用いて文字列変数への代入を行うことができます。

;「STR = あいう」と同様  
STR '= "あいう"  
;「STR = %TSTR:0%いろは」と同様  
STR '= TSTR:0 + "いろは"

文字列による配列変数の要素の指定¶

以下の変数について、引数を*.csvで定義した文字列にして呼び出すことができます。
Emueraの新規変数についての詳細はEmueraで追加された拡張文法 - 定数・変数をご覧ください。

ITEM (item.csv)  
ITEMSALES (item.csv)  
LOSEBASE (base.csv)  
BASE (base.csv)  
MAXBASE (base.csv)  
ABL (abl.csv)  
TALENT (talent.csv)  
EXP (exp.csv)  
MARK (mark.csv)  
RELATION (chara*.csv)  
UP (palam.csv)  
DOWN (palam.csv)  
PALAM (palam.csv)  
JUEL (palam.csv)  
GOTJUEL (palam.csv)  
STAIN (stain.csv)  
SOURCE (source.csv)  
EX (ex.csv)  
NOWEX (ex.csv)  
TEQUIP (tequip.csv)  
EQUIP (equip.csv)  
FLAG (flag.csv)  
TFLAG (tflag.csv)  
CFLAG (cflag.csv)  
STR (strname.csv)  
SAVESTR (savestr.csv)  
以下はEmueraから追加された変数  
ITEMPRICE (item.csv)  
DOWNBASE (base.csv)  
CUP (palam.csv)  
CDOWN (palam.csv)  
TCVAR (tcvar.csv)  
TSTR (tstr.csv)  
CSTR (cstr.csv)  
CDFLAG (cdflag1.csv, cdflag2.csv)  
GLOBAL (global.csv)  
GLOBALS (globals.csv)

例えばabl.csvに2,技巧という定義があれば、以下の4つの行は同じ意味になります。

ABL:技巧 += 1  
ABL:2 += 1  
ABL:"技巧" += 1  
ABL:(ABLNAME:2) += 1

RELATIONについてはNAME、CALLNAMEのいずれでも指定できます。
同名で複数の定義がある場合、先に定義されている方が呼ばれます。
例えばabl.csvに2,技巧と4,技巧があり、2,技巧の方が前の行で定義されているならば、ABL:技巧はABL:2になります。
文字列は式や変数でも可能です。その場合は以下のように()を付けてください。

ABL:(RESULTS:0) = ABL:(RESULTS:0) + 1

()を省略した場合、アイテム名と変数名が同一になる場合があります。その場合は変数が優先されます。
例えabl.csvに0,ローターという定義がある場合、

@HOGE  
#DIM ローター, 0  
ローター = 1  
PRINTFORML {ABL:ローター}

この場合、0番目のABLではなく1番目のABLであると解釈されます。
同様に、アイテム名が数値の場合、数値としての解釈が優先されます。
例えばabl.csvに0,10という定義をしABL:10を参照した場合は0番目のABLとは解釈されず10番目のABLとなります。
これはchara*.csv内の定義においても使用できます。
例えばabl.csvに2,技巧という定義があれば、以下の2つの行は同じ意味になります。

能力,2,2  
能力,技巧,2

ただし、相性(RELATION)には使えません。
chara*.csvを読んでいる段階ではシステムがcharaの名前とNOの対応を把握していないためです。
書式付文字列（FORM構文）拡張¶

PRINTFORMなどでつかわれる書式付文字列のうち、{}、%%に表示桁数（文字数）を指定できます。
{変数・数式等,表示桁数, 揃え(LEFT or RIGHT)}、%変数、文字列式等, 表示桁数, 揃え(LEFT or RIGHT)%という形式で指定します。
文字数は全角文字を2文字と数えます。
表示桁数（文字数）に足りない部分は半角スペースが追加されます。
通常は右揃えですが、キーワードLEFTを指定すると左揃えになります。
指定された表示桁数よりもとの桁数の方が大きい場合、そのまま表示します。

例

A = 123456  
STR:0 = あいう  
PRINTFORML [{A}]  
PRINTFORML [{A,10}]  
PRINTFORML [{A,10,LEFT}]  
PRINTFORML [%STR:0%]  
PRINTFORML [%STR:0,10%]  
PRINTFORML [%STR:0,10,LEFT%]  
PRINTFORML [{A,2}]  
PRINTFORML [%STR:0,2%]

結果

[123456]  
[    123456]  
[123456    ]  
[あいう]  
[    あいう]  
[あいう    ]  
[123456]  
[あいう]

文字列式中での書式付文字列（FORM構文）の使用¶

PRINTSやユーザー定義の式中関数の引数といった文字列式中でFORM構文を使用するとエラーになります。
そのため文字列式中で書式付文字列を使用する場合、文字列式中で定文字列を使うときに"～"を使用するのと同じように
@"～"を使用します。 また、@"～"の中の文字列が\@～\@を用いた三項演算子による記載のみである場合、@"～"を省略して直接\@～\@と書くことができます

正しい例

;代入はFORM構文  
STR:0 = あいう  
;加算は文字列式  
RESULTS += STR:0  
;文字列式に定文字列を使用する例  
RESULTS += "えお"  
;文字列式にFORM構文を使用する例  
PRINTS @"%RESULTS%かきくけこ"

;以下の4行はすべて同じである  
PRINTS STR:0 + "！"  
PRINTFORM %STR:0%！  
PRINTS @"%STR:0%！"  
PRINTFORM %STR:0 + "！"%

間違った例

;中身が「RESULTS」になる  
STR:0 = RESULTS  
;エラーが出る  
RESULTS += えお  
;エラーが出る  
RESULTS += %STR:0%  
;「@"」と「"」も表示される  
PRINTFORM @"%RESULTS%かきくけこ"

INPUTS系でのマクロ構文の使用¶

INPUTSやそれに類する入力受付命令で、マクロ式を用いることができます。
マクロの書式については利用方法のマクロの項目を確認してください。
マクロ構文を使わず、単なる文字列として()を使用する場合、\を用いてエスケープしてください。


evilmask.gitlab.io
演算 - Emuera.EM+EE ドキュメント
~2 分
演算¶
演算子¶
単項演算子¶

    ~ ビットごとの否定(ビットごとのNOT) 単項演算子（優先度最大）
    ! 論理否定(NOT) 単項演算子（優先度最大）

二項演算子¶

    << 左ビットシフト。比較やビット演算より優先度が高く、四則演算より低い。
    >> 右ビットシフト。比較やビット演算より優先度が高く、四則演算より低い。
    ^ ビットごとの排他論理和(ビットごとのXOR) 優先度は&、|と同じ
    ^^ ビットによらない排他論理和(ビットによらないXOR) 優先度は&&、||と同じ
    !& ビットによらない否定論理積(ビットによらないNAND) 優先度は&&、||と同じ
    !| ビットによらない否定論理和(ビットによらないNOR) 優先度は&&、||と同じ

三項演算子¶

    ?～# 普通の三項演算子 優先度は=の上で他の演算子より下（判定および結果を先にまとめてから処理される）

    書式（数値）　：<代入先変数> = <条件式> ? <真の場合の代入値> # <偽の場合の代入値>
    書式（文字列）：<代入先変数> = \@<条件式> ? <真の場合の代入値> # <偽の場合の代入値>\@

    処理的には

    IF <条件式>
        <代入先変数> = <真の場合の代入値>
    ELSE
        <代入先変数> = <偽の場合の代入値>
    ENDIF

    と同じになります。 なお、数値の三項演算子については、()の中に入れることにより、通常の計算の中で使うこともできますし、文字列の三項演算子については、そのままPRINTFORM系命令に使うことができます。 ただし、\@～\@形式の三項演算子では#を省略することはできません。

代入演算子¶

    '= 文字列式を用いた文字列型変数への代入を行う演算子 詳しくはこちら

インクリメント・デクリメント¶

    ++ インクリメント
    -- デクリメント 代入文の代わりに使います。他の演算子と組み合わせることはできません。

暫定的な演算子の優先度表¶
演算の追加¶

    == 文字列同士の比較。数値と文字列を比較することはできません。
    != 文字列同士の比較。
    < 文字列同士の比較。比較は先頭から行われ、異なる文字が見つかった時点で決定されます。
    > 文字列同士の比較。
    <= 文字列同士の比較。
    >= 文字列同士の比較。
    + 文字列同士の連結。数値と文字列を加算・連結することはできません。

    * 文字列と整数の乗算。文字列と文字列を乗算することはできません。

    例

    STR:0 = % "あ" * 10 %
    PRINTFORML STR:0 = "%STR:0%"
    WAIT

    結果

    STR:0 = "ああああああああああ"

論理演算子の短絡評価¶

短絡評価とはたとえば(X && Y)という式でXが0である時、Yの値によらず演算結果が0になることが明らかなのでYを評価しない、という評価法です。 吉里吉里を含む多くの言語では論理演算子を短絡評価します。 この評価法により以下のような書き方ができます。

IF (ASSI >= 0) && (NO:ASSI == 1)
    ～～～
ELSE 
    ～～～
ENDIF

ASSIが0以下の場合、(NO:ASSI == 1)の結果によらず全体の結果は0なのでNO:ASSIは参照されません。したがってエラーも発生しません。 評価順は左項が先、右項が後です。

IF (NO:ASSI == 1) && (ASSI >= 0)

このように書くと先に(NO:ASSI == 1)を計算しようとするのでASSI < 0のときエラーになります。


evilmask.gitlab.io
変数の仕様と一覧 - Emuera.EM+EE ドキュメント
7–9 分
変数の仕様と一覧¶

EmueraEM+EEの仕様に合わせて内容を補完しています
定数(リテラル)¶
定数の表記¶

Emueraでは8進数表記を除き、吉里吉里で使える定数の表記がそのまま使えます。
例えば以下の行は全て同じ意味になります。

X = 32  
X = 0b100000  
X = 0x20  
X = 1p5

上から順に、普通の10進表記、2進数、16進数、1×2の5乗、になります。
1p5のような表記はビット演算子と組み合わせ、各ビットを取得・設定したい時に便利です。
例えば下の条件文はAの下0ビット目または3ビット目が立っているときに真になります。

IF (A & 1p0) || (A & 1p3)

また、pの代わりにeを使うことでn×10のm乗を表せます。
例えば13e3は13000に等しくなります。
以上はあくまでも定数の表記ですので式を使うことはできません。
以下のような表記はエラーになります。

X = 13e(A + 1)

8進数表記についてはeramakerとの互換性の問題から採用していません。
012は10ではなく12と解釈されます。
変数¶
変数サイズの指定¶

EmueraではcsvフォルダにVariableSize.csvという名前のファイルを置くことで既存の変数の要素数を指定できます。
また、要素数に-1を指定することにより、ERB中でのその変数の使用を禁止することができます。

禁止設定された変数をERB中で代入や参照するとエラーになります。 禁止設定された変数をシステムが必要とする場合、代入処理は無視され、値は常に-1と扱われます。
（MONEYやNEXTCOMを禁止した場合に発生する状況です）
また、COUNTを使用禁止変数にした場合、REPEATも使用不可となり、実行時にエラー終了します（EM+EE）
ローカル変数¶
LOCAL¶
LOCALS¶

※この変数はobsoleteです。代わりに#DIM、#DIMSの使用を検討してください。
詳しくはユーザー定義の変数を参照してください。

ローカル変数（局所変数）です。
LOCALは整数、LOCALSは文字列となります
サイズは基本はLOCALが1000、LOCALSが100です。
また、#LOCALSIZE <設定する要素数>および#LOCALSSIZE <設定する要素数>
によって関数ごとに個別に要素数を変更できます。（ただし設定できる値は0より大きい整数）
セーブはされません。

@EVENTFIRST  
    LOCAL:10 = 123  
    CALL FUNC001  
    PRINTV LOCAL:10  
    WAIT  
@FUNC001  
    LOCAL:10 = 567  
    RETURN

上のコードのPRINTVの結果は123になります。
@FUNC001の中でLOCAL:10を変更していますが、@EVENTFIRST内のLOCALには変更が及びません。
多くの言語のローカル変数とは異なり、関数の呼び出しの際に初期化はされません。

内部的にはLOCAL@関数名という変数を作成しています。
なのでイベント関数など同じ名前の関数が複数ある場合は共用です。また、再帰的に呼び出された場合は同じ変数をつかうことになります。
LOCAL@EVENTFIRST:10 = 567のように他の関数用の変数も呼び出せますが推奨しません（デバッグ用の機能です）。
なお、他の関数のものを呼び出す時に、呼び出し先関数名に演算子等が含まれているとエラーとなります
ARG¶
ARGS¶

ローカル変数です。
ARGは整数、ARGSは文字列となります
サイズは基本はARGが1000、ARGSが100でVariableSize.csvで変更できます。
また、関数の引数で定義された分だけを問題なく使えるだけの要素数を自動で確保します。（VariableSize.csvで指定した数未満にはなりません）

@FUNC002, ARG:0, ARG:1, ARG,1100  
    LOCAL = ARG:0 * ARG:1 / 100  
    RETURN LOCAL

この場合、ARGの要素数は本来1000ですが、@FUNC002においてARGの要素数は0～1100の1101となります。
関数における引数指定のために使うことを想定しているので、それ以外の用途に用いると可読性が下がるかもしれません。
（ユーザー定義のプライベート変数）¶

特定の関数中で定義#DIMまたは#DIMSを用いて定義した変数はプライベート変数であるため、ローカル変数と同様に扱えます。
詳しくはユーザー定義の変数を参照してください。
セーブデータ間で共有される変数¶
GLOBAL¶
GLOBALS¶

異なるセーブデータ間で共有することができる変数です。
GLOBALは整数、GLOBALSは文字列となります
サイズは基本はGLOBALが1000、GLOBALSが100でVariableSize.csvで変更できます。
他のデータと一緒にはセーブ・ロードされません。
グローバル変数をセーブするにはSAVEGLOBAL命令を使います。
SAVEGLOBALを行うと、global.savにGLOBALとGLOBALSが保存されます。
書き込むときに既にglobal.savがある場合、上書きします
LOADGLOBAL命令により、global.savからGLOBALとGLOBALSを読み込めます。
LOADGLOBALは@EVENTFIRSTおよび@EVENTLOADのタイミングで行うことを勧めます。
GLOBAL、GLOBALSを経由すれば異なるセーブデータ間でデータを共有することができます。
（ユーザー定義のグローバル変数）¶

ERH中で定義#DIM GLOBALまたは#DIMS GLOBALを用いて定義した変数はグローバル変数となります。
また、#DIM SAVEDATA GLOBALとすることでセーブされるグローバル変数となります。
詳しくはヘッダーファイル（ERH）を参照してください。
キャラクタ変数¶
NICKNAME¶
MASTERNAME¶

NAMEやCALLNAMEと同様のセーブされる文字列型変数です。
chara*.csvではNICKNAME、MASTERNAMEまたはあだ名、主人の呼び方として指定します。
CSTR¶

セーブされる文字列配列変数です。
CFLAGの文字列版です。
chara*.csvではCSTRとして指定します。
CUP¶
CDOWN¶
DOWNBASE¶
TCVAR¶

数値型配列変数です。
それぞれ、UP、DOWN、LOSEBASE、TFLAGのキャラクタ変数版として使用することが想定されています。
そのため初期化タイミングやセーブの可不可もこれらの変数と同じです。
ただし、CUPとCDOWNはUPCHECK命令の代わりにCUPCHECK命令を使います。
CDFLAG¶

数値型キャラクター三次元配列変数です。

CDFLAG:MASTER:0:2

などのように第一引数がキャラ登録番号なのは従来のキャラクター変数と同じですが、
第二引数と第三引数が必要になります。
（ユーザー定義のキャラクタ変数）¶

ERH中で定義#DIM CHARADATAまたは#DIMS CHARADATAを用いて定義した変数はキャラクタ変数となり、CFLAGなどと同様自由に扱えます。
詳しくはヘッダーファイル（ERH）を参照してください。
csv関連¶
csv変数¶

各csvで定義された値を参照するための変数です。
使い方は例えばTALENTNAMEとtalent.csvの関係と同じです。
全て代入不可でセーブされない1次元配列変数です。
csvで定義されていない場合、0または空文字列を返します。

cstr.csv等とstr.csvの役割を混同しないでください。
str.csvは変数STRに代入される値を決めるファイルですが、cstr.csvはCSTRNAMEを定めるファイルです。
STRNAMEを定めるファイルはstrname.csvとなっています。str.csv及びstrname.csvの使い方に注意してください。
gamebase.csv変数¶

gamebase.csvで定義された値を参照するための変数です。
すべて非配列、代入不可、セーブされない変数です。
WINDOW_TITLE¶

Emueraのウィンドウのタイトルバーに表示されている文字列です。
非配列の文字列型変数です。初期値はgamebase.csvのウィンドウタイトルに設定された値です。
ウィンドウタイトルが設定されていなければタイトルとバージョンから生成します。
タイトルも設定されていない場合、Emueraになります。
その他のcsvに関わる変数¶
MONEYLABEL¶

お金の単位が記録された変数です。
非配列の文字列型変数で、代入不可、セーブされない変数です。
初期値は_Replace.csvにて設定されるお金の単位に設定された値です。
お金の単位が設定されていない場合、eramakerと同じ$になります。
DRAWLINESTR¶

DRAWLINE命令を行ったときに表示される文字列が記録された変数です。
非配列の文字列型変数で、代入不可、セーブされない変数です。
初期値は_Replace.csvにて設定されるDRAWLINE文字に設定された値を繰り返したものです。
そのためDRAWLINE文字に設定された値そのままの文字列が入っているわけではありません。
DRAWLINE文字が設定されていない場合、eramakerと同じ、例えば
------------------------------------------------------------------------------------------------------------になります。
セーブロード関連¶
LASTLOAD_*¶

最後にロードしたデータの情報を参照するための変数です。
参照はできますが代入はできません。
全て初期値は-1または空文字列です。
ロードした時に更新され、RESETDATAやメニューのタイトルに戻るを実行すると初期値に戻ります。
LASTLOAD_VERSION¶

最後にロードしたデータのバージョン（gamebase.csvで定義する値）
LASTLOAD_NO¶

最後にロードしたデータの番号（save*.savの*に相当する番号）
LASTLOAD_TEXT¶

テキスト（PUTFORMで追加するテキスト。SAVEDATA_TEXT）
SAVEDATA_TEXT¶

セーブデータに保存され、セーブ/ロード画面で表示されるテキストです。
ロード後にLASTLOAD_TEXTで参照できるテキストでもあります。
参照も代入も可能です。
@SAVEINFOが呼ばれる時に現在時刻を表す文字列が代入され、PUTFORMで追記することができる文字列です。
@SAVEINFO中でこの文字列に直接代入することで時刻表示もカスタマイズできます。
SAVEGAMEとPUTFORMを使わない（SAVELOAD.ERBを使う場合）には出番がありません。
（ユーザー定義のセーブ可能な広域変数）¶

ERH中で定義#DIM SAVEDATAまたは#DIMS SAVEDATA"を用いて定義した変数はセーブ可能な広域変数となります。
ただし、#DIMS SAVEDATAを用いてセーブ可能な多次元広域変数を定義する場合、オプションセーブデータをバイナリ形式で保存するが有効になっている必要があります。
詳しくはヘッダーファイル（ERH）を参照してください。
多次元配列変数¶
DITEMTYPE¶
DA ～ DE¶

※この変数はobsoleteです。代わりに#DIM、#DIMSを使用して用途に応じた名前を付けることを検討してください。
詳しくはユーザー定義の変数を参照してください。

固定長の整数型二次元配列です。
DITEMTYPE:1:2のように呼び出します。引数は省略できません。
eramakerの二重配列は第一引数にはキャラクタ登録番号を指定するのでCHARANUMによって配列の大きさが異なります。
DITEMTYPEなどの二次元配列はVariableSize.csvで指定した大きさのまま変化することはありません。
VARSIZE命令の対象にした場合、RESULT:0とRESULT:1にそれぞれ要素数が代入されます。
VariableSize.csvでDITEMTYPE,100,200としているとDITEMTYPE:99:199まで使用でき、VARSIZE命令ではRESULT:0とRESULT:1に100と200が代入されます。
TA, TB¶

※この変数はobsoleteです。代わりに#DIM、#DIMSを使用して用途に応じた名前を付けることを検討してください。
詳しくはユーザー定義の変数を参照してください。

固定長の整数型三次元配列です。
TA:1:2:3のように呼び出します。引数は省略できません。
サイズは標準では100×100×100です。つまりTA:99:99:99まで使えます。
VariableSize.csvでサイズを変更することが可能ですが、合計で100万を超えるサイズは指定できません。
VARSIZE命令の対象にした場合、RESULT:0とRESULT:1とRESULT:2にそれぞれの要素数が代入されます。
（ユーザー定義の多次元配列変数）¶

ver1.808以降、定義#DIMまたは#DIMSを用いて定義した変数を多次元とすることができるようになりました。
詳しくはユーザー定義の変数を参照してください。
デバッグ変数¶

デバッグ変数はデバッグ用の情報を提供するための変数です。
デバッグ変数はデバッグモードで起動したときのみ意味のある値を返します。
通常モードで起動したときには空文字列又は0を返します。

全て名前の前と後ろにアンダースコア_が2つ付いています。
__FILE__¶

一次元読み取り専用変数です。
現在実行中のスクリプトのファイル名を返します。
ファイル名はエラー情報などと同じようにフォルダ構造及び拡張子までを含む形式です。

システム入力待ち中にデバッグコマンドや変数ウォッチから参照した場合など、
現在実行中のスクリプトがない場合は空文字列を返します。
__LINE__¶

一次元読み取り専用変数です。
現在実行中のスクリプトの行番号を返します。
行番号はエラー情報などと同じように1から始まる数字です。

現在実行中のスクリプトがない場合は-1を返します。
__FUNCTION__¶

一次元読み取り専用変数です。
現在実行中の関数名を返します。
関数名は@及び引数のリストを含みません。

現在実行中のスクリプトがない場合は空文字列を返します。
その他¶
TSTR¶

文字列型1次元配列です。一次元配列で、セーブはされません。
TFLAGと同じタイミングで初期化されます。
RANDDATA¶

乱数の状態を記憶するための配列です。数値型の一次元配列で代入可、セーブされます。
DUMPRANDによって記録され、INITRANDによって読み出されます。
LINECOUNT¶

これまでにPRINTした行数を返す変数です。
LINECOUNTは起動直後から改行(ウインドウ幅による改行を含まない)のたび+1、CLEARLINEした数だけ-されます。
ログバッファー(標準5000)をあふれたことによる削除によっては変動しません。
非配列の数値型変数で、代入・セーブ共に不可能です。
また、行の数え方はCLEARLINEと同様です。
ISTIMEOUT¶

以下、私家改造版1809+v2に添付のreadmeより

○TINPUT系がタイムアウトしたかをチェックする変数ISTIMEOUT追加  
　TINPUT系が呼び出された時に0に初期化され、タイムアウトすると1となります。

ver1815現在、この変数は利用不能な可能性があります。
__INT_MAX__¶
__INT_MIN__¶

数値型変数の定義域最大値、最小値という定数が記録されている非配列の数値型変数で、代入・セーブ共に不可能です。
デバッグ変数ではないので普通に起動した場合でも使用できます。
（ユーザー定義の広域変数）¶

ERH中で定義#DIMまたは#DIMSを用いて定義した変数は広域変数となり、一文字変数（Aなど）同様自由に扱えます。
詳しくはヘッダーファイル（ERH）を参照してください。
（ユーザー定義の定数）¶

ERH中および特定の関数中で、定義#DIMまたは#DIMSを用いて定義した変数は1次元配列の定数となり、代入できない変数として扱えます。
詳しくはユーザー定義の変数を参照してください。
（ユーザー定義の参照型変数）¶

特定の関数中で定義#DIM REFまたは#DIMS REFを用いて定義した変数は参照型変数となります。
詳しくはユーザー定義の変数を参照してください。
makerとの仕様の違い¶
NAME¶
CALLNAME¶

eramakerでは代入ができません。
Emueraでは代入できるようになっています。
RAND¶
CHARANUM¶

eramakerでは代入でき、セーブ・ロードされますが代入した値を使用する方法がありません。
Emueraでは代入を禁止しています。
暫定的な仕様表¶
eramakerにも存在していた変数¶
Emuera専用変数¶


evilmask.gitlab.io
ユーザー定義の変数 - Emuera.EM+EE ドキュメント
4–5 分
ユーザー定義の変数¶

#DIMおよび#DIMSを利用することで好きな変数を定義することが可能です。
関数内で定義した変数はその関数内でのみ使用可能なプライベート変数に、
ヘッダーファイル（ERH）内で定義した変数はERB中の全ての箇所から参照できる広域変数になります。
書式（プライベート変数の場合）¶

その変数を定義したい関数の宣言の下に#DIM(S) <変数名>, <要素数>{, <要素数>{, <要素数>}}を記述します。
<変数名>は関数名と同様に、先頭が数字でなく、記号は_のみで構成された任意の文字列です。
<要素数>はすべて1～1000000の範囲内の任意の整数または定数式です。省略した場合、1となります。
<要素数>をいくつ与えたかによって、定義される変数の次元が変化します。最大は三次元で、四次元以上の変数を定義することはできません。
#DIM(S)によるプライベート変数は単一関数中に複数定義できます。

これにより、<変数名>で指定した名前の変数がその関数内で使用可能になります。
変数は<要素数>で指定した要素数で代入可能、セーブはされません。初期値は0または空文字列です。
#DIMで定義すると整数型変数に、#DIMSで定義すると文字列型変数になります。
#DIM(S)で定義した変数はその関数の引数に指定することも可能です。初期値も設定できます。

@FIND_CSTR(KEY, VALUE)  
#FUNCTION  
#DIM LCOUNT  
#DIM KEY  
#DIMS VALUE  
SIF KEY < 0 || KEY >= VARSIZE("CSTR")  
    RETURNF -1  
FOR LCOUNT, 0, CHARANUM  
    SIF LCOUNT == MASTER  
        CONTINUE  
    SIF CSTR:LCOUNT:KEY == VALUE  
        RETURNF LCOUNT  
NEXT

上のスプリクトのように、用途に合わせた変数名をつけ、適切な要素数を設定することで
連続的でないLOCALの多用による可読性の低下を改善することができるかもしれません。
初期値の設定¶

1次元配列変数を宣言する際、初期値を定義することができます。
初期値を定義した配列の要素数は省略することができ、その場合初期値の数が自動的に配列の要素数になります。
配列の要素数を省略しない場合はその数字が配列の要素数になります。
要素数が省略されておらず、かつ初期値の数が要素数より多い場合にはエラーになります。

;要素数を省略したためHOGEの要素数は3  
#DIM HOGE = 1,2,3

;要素数を省略しないためPUGEの要素数は100  
#DIM PUGE,100 = 4,5,6

;エラー（初期値の数が指定した要素数より多い）  
#DIM HIGE,1 = 7,8,9

;文字列変数でも可能（文字列式で指定）  
#DIMS SHOGE = "A", "B", "C"

なお、多次元配列には初期値を定義できません。
動的変数¶

#DIM(S) DYNAMIC <変数名>, <要素数>のように変数名の前にDYNAMICを入れると、定義された変数は動的に確保されます。
具体的には関数が呼ばれたときに確保され、関数が終了したときに変数とその中の値は消滅します。
（RESTART命令は「関数の最初に戻る命令」であるため、動的に確保した変数であってもリセットされることはありません）
関数中に自分自身を呼出（再帰）した場合も再帰した回数だけ変数が確保されるため再帰処理の挙動が安定します。
ただしDYNAMICを入れない場合（静的変数）に比べ動作が遅くなります。
定数¶

1次元配列変数を定義する際に変数名の前にCONSTを入れると、1次元配列の定数が定義されます。
初期値同様に、1次元配列変数のみ定義することができます。
定数の宣言には必ず初期値が必要で、また途中で代入して変更することはできません。
またCONSTはその性質上、GLOBAL、SAVEDATA、REF、DYNAMICキーワードと同時には使用できません。
なお、配列の要素数を省略せずに指定することもできますが、要素数と初期値の数が一致しない場合エラーになります。

;1次元定数配列の定義  
#DIM CONST HOGE = 1,2,3

;エラー（初期値の数と要素数が一致しない）  
#DIM CONST PUGE,100 = 4,5,6

;文字列変数でも可能（文字列式で指定）  
#DIMS CONST SHOGE = "A", "B", "C"

参照型変数¶

変数名の前にREFキーワードを用いることで、参照型変数を定義できます。
整数型1～3次元配列、文字列型1～3次元配列はそれぞれ以下のように宣言します。

#DIM REF HOGE1DIM,0  
#DIM REF HOGE2DIM,0,0  
#DIM REF HOGE3DIM,0,0,0  
#DIMS REF PUGE1DIM,0  
#DIMS REF PUGE2DIM,0,0  
#DIMS REF PUGE3DIM,0,0,0

カンマの数があっていれば0は省略してもかまいません。1次元配列の場合はカンマも省略できます。
参照型変数は実体を持たず、参照型変数を操作するとREF命令（ver1.815現在は利用不能）又は参照渡しにより渡された変数が代わりに操作されることになります。
参照渡しの詳細は関数-引数の参照渡しを確認してください。
書式（広域変数の場合）¶

ヘッダーファイル（ERH）内に#DIM(S)を記述した場合、ERB中で定義するプライベート変数とは異なり、
ERB中の全ての箇所から参照できる広域変数になります。
プライベート変数とは異なりDYNAMIC、STATICの区別はなく、REFを用いた参照型変数を定義することもできませんが、CONSTを用いた定数は同様に定義できます。
関数中におけるDIMにはない機能としてセーブされる変数やグローバル変数、キャラ変数を定義することが可能です。
詳しくはヘッダーファイル（ERH）の項目をご確認ください。
制限¶
命令と同じ名前は使用不可¶

以下のように、命令と同じ名前の変数を定義することはできません。

;エラー  
#DIM PRINTFORM  
#DIM SELECTCASE  
#DIM CALL  
#DIM RETURN  
#DIM GOTO  
#DIM SQRT  
#DIM DATAFORM  
#DIM NOSKIP  
#DIM FUNC  
#DIM ENDFUNC

関数名・プリプロセッサと同じ名前の変数は定義できますが、推奨できません。

;推奨しない  
#DIM EVENTFIRST  
#DIM COMF32  
#DIM COMABLE15  
#DIM SHOW_ABLUP_SELECT  
#DIM DIM  
#DIM PRI  
#DIM ONLY  
#DIM SKIPSTART

関数の外部からの干渉¶

LOCAL@HOGEのあるLOCALと異なり、他の関数のプライベート変数を参照したり、代入したりする方法はありません。
ERD(ERabasic Define)機能¶

EM+EEで追加された機能です。ERH内で定義した変数に、CSV変数と同じように*.csvファイル、もしくは*.ERDファイルを使用して識別子を設定することができます
以下、EM+EEサマリーからの引用

ERHで定義した変数名を準拠にファイルを読み込み、既存のCSV変数と同じように配列に名前を付けることができる
CSVフォルダ内で使えるものは従来どおり「変数名.csv」、ERB内で使えるものは「変数名.ERD」ファイルとなる。書式はCSV変数のファイルと同じ。これらが2つ以上存在しても、同じ識別子が定義されている場合だけ起動時にエラー吐いて終了する。違う識別子を同じ整数に置き換え可能
また、多次元配列の変数に名前を付ける場合は、各次元に応じてファイル名に@から続く数字を記すことで対応する。左の添字から1,2,3と対応している

ERH

#DIM HOGE, 3
#DIM HOGE2D, 3, 3
#DIM HOGE3D, 3, 3, 3

ファイル構成

HOGE.ERD
HOGE2D@1.ERD
HOGE2D@2.ERD
HOGE3D@1.ERD
HOGE3D@2.ERD
HOGE3D@3.ERD


evilmask.gitlab.io
関数・プリプロセッサ - Emuera.EM+EE ドキュメント
5–7 分
関数・プリプロセッサ¶
@EVENTLOAD¶

データをロードした直後に呼び出されます。
イベント関数なので複数定義することができます。
@EVENTLOADが定義されていない場合、@SHOW_SHOPへ移行します（eramakerと同じ動作）
@TITLE_LOADGAME¶

標準のタイトル画面でロードを選択した場合に呼び出されます。
@TITLE_LOADGAMEを定義することでタイトルでも独自のロード画面を使用することができます。
定義されていない場合、標準のロード画面が使用されます。
@SYSTEM_TITLEを定義した場合、明示的にCALLしない限り@TITLE_LOADGAMEが呼ばれることはありません。
@SYSTEM_AUTOSAVE¶

オートセーブが行われるタイミングで呼び出されます。
オートセーブの内容を独自に定めることができます。
定義されていない場合、標準のセーブ機能が使用されます。
@SYSTEM_TITLE¶

csvのロードが終了したタイミングで呼び出されます。
また、BEGIN TITLEによっても呼び出されます。
@SYSTEM_TITLEを定義することで独自のタイトル画面を使用することができます。
定義されていない場合、標準のタイトル画面が使用されます。
@CALLTRAINEND¶

CALLTRAINによる自動実行が終了後、システム内部から自動的に呼び出される関数です。
イベント関数ではないため多重定義できないことに注意してください。
自作関数における引数指定¶
書式¶

関数側

@(関数名),(引数1),{(引数2)....}
　　　引数は数値ならARG(:0,1,2...)、文字列ならARGS(:0,1,2...)
　　　関数中で#DIM、#DIMSを用いて定義したプライベート変数も引数に指定可能

呼び出し側

CALL (関数名),(引数1),{(引数2)....}

数値は数式または文字列式が使用できます。
文字列リテラル（定数）を引数にするときは""でくくってください。
書式付の文字列リテラルを引数にするときは@"～～"で書いてください。
CALL以外にJUMP、CALLFORM、TRYCALLなどでも同じ書式が使えます。
関数側の引数はいくつでも指定できます。
ver1.808現在、関数側と呼び出し側で型が異なる場合、数値から文字列、文字列から数値に関わらず変換せずエラーになります。
ver1.807以前と同様に文字列型の引数に数値を与えて呼び出したい場合、コンフィグ設定を変更するか、TOSTR関数を用いてください。
引数は省略できます。省略した場合、数値型の場合は0、文字列型の場合は空文字列が代入されます（初期値を設定していない場合）。
呼び出された関数側ではARGとARGSで渡された値を参照できます
基本的に値渡しなのでARGの中身を変更しても渡した元の変数等の値は変化しないことに注意してください。
ARGやARGS、または関数中で#DIM、#DIMSを用いて定義したプライベート変数以外の変数（AやSTR）を引数にすることも可能ですが、いくつか制限があります。
ver1.808現在、これらの変数を用いた場合は初期値を設定できず、また引数を省略できません。

;定義  
@FOOBAR, ARG:0, ARGS:0  
    ～～  
@HOGEHOGE, ARG:0, ARG:1, ARG:2  
    ～～  
;呼び出し  
;変数で指定  
    CALL FOOBAR, X , STR:0  
;定数で指定  
    CALL FOOBAR, 123 , "あいう"  
;書式付文字列で指定  
    CALL FOOBAR, 123 , @"[{COUNT}] あいう"  
;式で指定  
    CALL FOOBAR, X + 10, "あいう" * 10  
;引数の省略-全部  
    CALL FOOBAR  
;引数の省略-第１引数  
    CALL FOOBAR, , "あいう"  
;引数の省略-第２引数  
    CALL FOOBAR, 123

<エラーになる例>

;エラー(引数が多すぎる)  
    CALL FOOBAR, X , STR:0, Y  
;エラー(引数の型が違う-数値型の第1引数に文字列を代入しようとしている)  
    CALL FOOBAR, "あいう", "かきく"  
;エラー(引数の型が違う-文字列型の第2引数に数値を代入しようとしている)  
    CALL FOOBAR, 123 , 456

<動作はするが推奨されない例>

;代入先はARG、ARGSでなくても可能ですが、通常はARGを使うことを推奨します  
@FOOBAR, X, Y  
;代入先を可変にすることも可能ですが可読性が下がります。  
@FOOBAR, ARG:X, ARG:Y  
;可読性が下がります。  
@FOOBAR, ARG:0, ARG:(ARG:0)

引数の初期値¶

関数の引数に初期値を設定することができます。
初期値を設定する場合、関数側は以下のようになります。

@(関数名),(引数1 = 初期値1),{(引数2 = 初期値2)....}  
引数は数値ならARG(:0,1,2...)、文字列ならARGS(:0,1,2...)、  
または関数中で#DIM、#DIMSを用いて定義したプライベート変数  
それ以外を指定した場合初期値は設定できません。

指定可能な初期値は定数および定文字列のみで、変数は指定できません。
また文字列の初期値は""でくくってください。
初期値を設定し、呼び出し側が引数を省略した場合、初期値に設定した値が代入されます。
省略せずに関数を呼び出した場合は、通常通りARGとARGSに渡された値が代入されます。

;初期値設定（部分省略もできます）  
@FUNCTION, ARGS:0 = "かきく", ARG:0 = 111, ARG:1, ARG:2 = 200  
    ～～

;エラー(初期値は定数および定文字列のみ)  
@FOOBAR, ARG:0 = MASTER, ARG:1 = TARGET  
;ARG、ARGS,関数中で#DIM,#DIMSを用いて定義したプライベート変数以外の引数に初期値を設定しても無視されます。  
;そのため想定通りの動作ができません。  
@FOOBAR, X = 5, Y = 4

引数の参照渡し¶

ver1.810から、参照型変数を仮引数にすることで引数の参照渡しができるようになりました。
参照型変数の定義方法は参照型変数の項を確認してください。

@SYSTEM_TITLE  
A = 0  
CALL TEST(A)  
B = 1  
CALL TEST(B)  
PRINTFORML A == {A}  
PRINTFORML B == {B}  
WAIT

@TEST(HOGE)  
#DIM REF HOGE  
HOGE = 100  
RETURN

<実行結果>

A == 100  
B == 100

上の例で関数@TESTは仮引数に参照型変数を持ちます。
1回目に@TESTが呼ばれたとき、HOGEは実引数Aを参照するようになります。
関数@TEST中でHOGE = 100とすることで参照先の変数Aに100が代入されるので1回目のPRINTFORMLの結果は100になります。
同様に2回目の@TESTが呼ばれると変数Bに100が代入され、2回目のPRINTFORMLの結果も100になります。
属性¶

関数の仕様や動作を決定するプリプロセッサです。
関数に#から始まるプリプロセッサを記述する場合、関数の直下にしなくてはなりません。
#ONLY¶

イベント関数専用の属性です。
#ONLYが指定されたイベント関数がある場合、その1つのみが実行され、他の同名イベント関数を実行されません。
また#ONLYが指定された同名イベント関数が複数ある場合も実行されるのは「最初の1つ」のみとなります。
#FUNCTION¶

式中関数の属性です。
式中関数は通常のRETURNで終了することはできず、代わりにRETURNF <数式>で終了する必要があります。
詳しくはユーザー定義の式中関数を参照してください。
#FUNCTIONS¶

式中関数の属性です。
式中関数は通常のRETURNで終了することはできず、代わりにRETURNF <文字列式>で終了する必要があります。
詳しくはユーザー定義の式中関数を参照してください。
定義¶

変数の名前やその仕様を定義するプリプロセッサです。
関数に#から始まるプリプロセッサを記述する場合、関数の直下にしなくてはなりません。
#LOCALSIZE <定数式>¶
#LOCALSSIZE <定数式>¶

関数ごとに個別にLOCALおよびLOCALSの要素数を指定するためのプリプロセッサです。
定数式の結果は0より大きい整数である必要があり、それ以外もしくは変数を含んだ式や解釈できない文字列が与えられた場合は無視されます。
無視された場合またはこのプリプロセッサを使用しなかった場合は通常通りVariableSize.csvの設定値を使用します。
イベント関数にこのプリプロセッサを使用した場合、一番最初に実行されるものの設定が使用されます(ver1800現在)。
#DIM¶

ユーザー定義変数宣言です。ERB中の特定の関数内で使用することで、その関数内でのみ使用可能な数値型変数を定義できます。
詳しくはユーザー定義の変数を参照してください。
また、ERH中で使用することで、すべての関数で値を共有できる数値型変数を定義できます。
詳しくはヘッダーファイル（ERH）を参照してください。
#DIMS¶

ユーザー定義変数宣言です。ERB中の特定の関数内で使用することで、その関数内でのみ使用可能な文字列型変数を定義できます。
詳しくはユーザー定義の変数を参照してください。 また、ERH中で使用することで、すべての関数で値を共有できる文字列型変数を定義できます。
詳しくはヘッダーファイル（ERH）を参照してください。
#DEFINE¶

DEFINEマクロの宣言です。ERH中で使用することで、全ERBコード中の文字列をあらかじめ定義した別の文字列へ置換することができます。
詳しくはヘッダーファイル（ERH）を参照してください。
特殊なブロックを表す行¶

これらはプリプロセッサ行です。
これらを記述した同一行において、その直後に続けて命令や関数やコメントなどを記述してはいけません。
これらはeramakerでは解釈できないためコーディングするときに場合によっては;!;を使う必要があります。
[SKIPSTART]¶
[SKIPEND]¶

[SKIPSTART]から[SKIPEND]までの間に書いた行はEmueraでは読み込まれず実行されません。
これはEmueraとeramakerで挙動を意図的に変えたいときに使われるものです。
Emueraでは実行してほしくない文を記述する際に使ってください。
また、;!;と併用することで、Emuera以外では実行してほしくない文を記述することができます。
詳しくはEmueraで追加された記法の項目を参照してください。
[IF XXX]¶
[ELSEIF XXX]¶
[ELSE]¶
[ENDIF]¶

ある名称XXXのマクロが定義されているかどうかによって複数の行を実行するかどうか、分岐することができます。
詳しくはヘッダーファイル（ERH）を参照してください。
[IF_DEBUG]¶
[ENDIF]¶

[IF_DEBUG]から[ENDIF]までの間に書いた行はデバッグモード時のみ実行されます。
非デバッグモード時はコメント行と見なされ実行されません。
ただし、DEBUG系命令は元々非デバッグモード時には無視されるので、;#;を行頭に付ける必要はありません。
同様にデバッグ変数も非デバッグモード時には空文字列又は0のため、エラーの心配はありません。
デバッグモードについてはこちらを参照してください。
[IF_NDEBUG]¶
[ENDIF]¶

[IF_NDEBUG]から[ENDIF]までの間に書いた行は非デバッグモード時のみ実行されます。
デバッグモード時はコメント行と見なされ実行されません。
[IF_DEBUG]とは判定が逆になっています。
デバッグモードについてはこちらを参照してください。


evilmask.gitlab.io
ユーザー定義の式中関数 - Emuera.EM+EE ドキュメント
3–4 分
ユーザー定義の式中関数¶

「式中で使える関数」として、組み込み関数だけでなく@～～で定義した関数を式中で呼び出すことも可能です。
「式中で使える関数」のうち組み込み関数については式中で使える関数を参照してください。
書式¶

呼び出される関数は#FUNCTIONフラグまたは#FUNCTIONSフラグを持ち、RETURNFで終わる必要があります。

#FUNCTIONを付けると数値を返す関数と認識されます。
#FUNCTIONSを付けると文字列を返す関数と認識されます。
#FUNCTION(S)を付けた関数は通常のRETURNで終了することはできません。代わりにRETURNFで終了します。
RETURNFには数式または文字列式を指定します。これは#FUNCTION(S)で示した型と一致している必要があります。
RETURNFの引数を省略した場合、またはRETURNF無しで関数の終端に到達した場合は0または空文字列を返します。

X = GET_CFLAG(TARGET, Y)  
STR = %GET_NAME(TARGET)%

@GET_CFLAG(ARG:0, ARG:1)  
#FUNCTION  
    SIF ARG:0 <= 0 || ARG:0 >= CHARANUM  
        RETURNF 0  
    RETURNF CFLAG:(ARG:0):(ARG:1)

@GET_NAME(ARG:0)  
#FUNCTIONS  
    SIF ARG:0 <= 0 || ARG:0 >= CHARANUM  
        RETURNF ""  
    RETURNF NAME:(ARG:0)

※関数定義の引数を()でくくっていますが、これは定義の場合は必須な文法ではありません。
式中関数を呼び出す場合は()でくくった文法を用いる必要があります。
通常の関数と同様に関数名と引数をカンマでわけることもできます。
以下の2行は同じ意味です。

@GET_CFLAG(ARG:0, ARG:1)  
@GET_CFLAG, ARG, ARG:1

また、引数に初期値を設定することができます。
初期値についての文法は自作関数における引数指定をご覧ください。
制限¶
CALLから呼び出せない¶

FUNCTION(S)フラグを付けた関数はCALLなど通常の呼び出しはできません。
式中でのみ呼び出せます。

    ;エラー  
    CALL GET_CFLAG, X, Y  
@GET_CFLAG(ARG:0, ARG:1)  
#FUNCTION  
    SIF ARG:0 <= 0 || ARG:0 >= CHARANUM  
        RETURNF 0  
    RETURNF CFLAG:(ARG:0):(ARG:1)

#FUNCTION(S)を呼び出すための専用命令CALLF、CALLFORMFからであれば呼び出せます。
一部の命令は使用不可¶

FUNCTION(S)フラグを付けた関数の中ではWAITなど入力を伴う命令、CALLなど関数呼び出しを伴う命令は使用できません。
使用するとエラーになります。

CALL命令は使用できませんが、FUNCTION(S)フラグを持つ関数を式中で呼び出すことはできます。
また、CALLF、CALLFORMF命令による#FUNCTION(S)の呼び出しは可能です。
オーバーロード不可¶

複数の#FUNCTION(S)関数を引数の数、型の違いによって呼び分けることはできません。
同じ名前の関数は1つしか定義できず、同名関数を複数定義した場合には最初に定義された関数のみが有効です。
組み込み関数の上書き¶

組み込み関数と同名の関数を定義した場合、その組み込み関数は呼び出せなくなります。
例えば、@ABSを定義すると元のABSを呼び出すことはできなくなります。
組み込み関数が上書きされているとき、Emueraは起動時に警告を表示します。
組み込み関数が上書きされていると意図した動作をしないことがあるため、コンフィグによって関数の上書きを禁止することができます。
意図的に上書きする場合のため（推奨しません）、上書きされても警告しないようにするコンフィグオプションもあります。
注意事項¶

FUNCTION(S)フラグを付けた関数の中でローカル変数以外の変数を変化させるべきではありません。
ローカル変数以外の変数を変化させる関数（副作用のある関数）は後述する短絡評価や式の評価順序などにより動作が変わるおそれがあります。
また、デバッグコマンドやデバッグ用の変数ウォッチウインドウからなどの予期しない呼び出しにより意図しない動作をするおそれがあります。
短絡評価による呼び出し省略¶

式中に関数があっても短絡評価によって呼び出されないことがあります。

例えば以下のスクリプトは、IF文の中でGET_ASSI_CFLAGを呼んでおり、GET_ASSI_CFLAGの中でASSIを変更しています。

    IF X || GET_ASSI_CFLAG(0)  
        Y = CFLAG:ASSI:2  
    ENDIF  
@GET_ASSI_CFLAG(ARG:0)  
#FUNCTION  
    SIF ASSI < 0  
        ASSI = 0  
    RETURNF CFLAG:ASSI:(ARG:0)

一見するとY = CFLAG:ASSI:2の実行時にASSI < 0になることはないように見えます。
しかし、Xが0でない場合は短絡評価によりGET_ASSI_CFLAGが実行されないため、ASSI < 0のままCFLAG:ASSI:2を評価しようとしてエラーになる場合があります。
式の評価順により結果が変わる¶

式中での変数・関数の評価順は不定です。
副作用のある関数は式の中の関数がどの順番で呼び出されるかに依存する場合があります。
そのようなコードを書かないでください。
呼び出し順はEmueraのバージョンが同じであれば同じになるでしょうが、将来変更されるかもしれません。
下のスクリプトでは、@ADDCHARA_CFLAG中でTARGETを変更しています。

    X = CFLAG:TARGET:10 + ADDCHARA_CFLAG(0)  
@ADDCHARA_CFLAG(ARG)  
#FUNCTION  
    ADDCHARA ARG  
    TARGET = CHARANUM -1  
    RETURNF CFLAG:TARGET:2

@ADDCHARA_CFLAGより前にCFLAG:TARGET:10を評価するか、後でCFLAG:TARGET:10を評価するかによってCFLAG:TARGET:10の指す変数が変わってきます。
したがってこのスクリプトは評価順に依存します。
#FUNCTION(S)フラグを付けた関数の中でADDCHARAやTARGETへの代入をすべきではありません。
デバッグ用の機能により呼び出されることがある
#FUNCTION(S)フラグを付けた関数は*.ERBファイル中のスクリプトからだけではなく、デバッグコマンドやデバッグ用の変数ウォッチウインドウから動的に呼び出されることがあります。
特に変数ウォッチは頻繁に値を更新しようとし、更新のたびにその関数を呼び出します。
副作用を持つ関数はこのような呼び出しにより誤動作を起こす可能性があります。


evilmask.gitlab.io
ヘッダーファイル - Emuera.EM+EE ドキュメント
6–7 分
ヘッダーファイル¶

ERBフォルダの中には拡張子ERBのファイルのほか、拡張子ERHのファイルを置くことができます。
ERHファイルにはERBより先に処理すべき内容を記載します。
具体的には#DIM及び#DIMSによる広域変数の定義と#DEFINEによるマクロの定義です。
ヘッダー中に#DIM、#DIMSと#DEFINE以外の行を書いてはいけません。

EmueraはERBフォルダ内に置かれた*.ERHを全て読んでいきます。
処理順はcsvフォルダ内のファイル→*.ERH→*.ERBの順なのでERHの効果はCSVフォルダ内の記述には及びません。
逆に、_rename.csvによる置換は*.ERHにも適用されます。
eramakerEXは*.ERHには_rename.csvを適用しないため、ERHファイルを用いるとeramakerEXとの互換性は失われます。
広域変数の宣言¶

※ユーザー定義の変数も参照してください。

ヘッダーファイルでは新しい変数を宣言することができます。
これはERB中で宣言するプライベート変数とは異なり、ERB中の全ての箇所から参照できる広域変数になります。
プライベート変数とは異なりDYNAMIC、STATICの区別はなく、REFを用いた参照型変数を宣言することもできませんが、CONSTを用いた定数は同様に宣言できます。
宣言できる変数は3次元変数までを宣言することができます。
要素数を指定しない場合、要素数1の配列になるので非配列変数のように使うこともできます。
変数宣言は以下のように#DIM又は#DIMSにより行います。
なお、#DIM HOGE,1,2のようにすると二次元配列になります。

<*.ERH>  
    #DIM MY_INT  
    #DIM MY_INT_ARRAY, 100  
    #DIMS MY_STR  
    #DIMS MY_STR_ARRAY, 100

ERH中で上のように定義しておくことで、ERB中では

<*.ERB>  
    MY_INT = 100  
    MY_INT_ARRAY:10 = MY_INT_ARRAY:10 + 45  
    MY_STR = あああ  
    PRINTFORML {MY_INT_ARRAY:10} %MY_STR%

のように変数として使用できます。
#DIMによる変数宣言の要素数の指定は数値で行う他に定数式でも指定できます。
ただし、*.ERB中の#DIMと異なりマクロが展開されないことに注意してください。
SAVEDATA キーワード¶

変数宣言時にSAVEDATAキーワードを加えることでセーブされる変数が宣言できます。
ただしSAVEDATAキーワードを用いてセーブ可能な多次元変数を宣言する場合、オプションセーブデータをバイナリ形式で保存するが有効になっている必要があります。

<*.ERH>  
    #DIM SAVEDATA MY_INT_ARRAY, 100  
    #DIMS SAVEDATA MY_STR_ARRAY, 100

このように宣言することでMY_INT_ARRAY、MY_STR_ARRAYの内容はDAYやMONEYなどの既存変数と同様にセーブされロードされます。
逆に言えばSAVEDATAキーワードを付けずに宣言した変数はセーブされず、ロード時には初期化されます。
CHARADATA キーワード¶

変数宣言時にCHARADATAキーワードを加えることでキャラクタ変数が宣言できます。
CHARADATAはSAVEDATAキーワードと同時に使用することができます。

<*.ERH>  
    #DIM CHARADATA C_INT_ARRAY, 100  
    #DIMS CHARADATA C_STR_ARRAY, 100  
    #DIM CHARADATA SAVEDATA CS_INT_ARRAY, 100

上の例ではC_INT_ARRAY、C_STR_ARRAYはキャラクタ変数ですがセーブロードはされません。
CS_INT_ARRAYはキャラクタ変数であり、かつセーブもロードもされます。
GLOBAL キーワード¶

変数宣言時にGLOBALキーワードを加えることでグローバル変数が宣言できます。
GLOBALはSAVEDATAキーワードと同時に使用することができます。

<*.ERH>  
    #DIM GLOBAL G_INT_ARRAY, 100  
    #DIMS GLOBAL G_STR_ARRAY, 100  
    #DIM GLOBAL SAVEDATA GS_INT_ARRAY, 100

グローバル変数は通常のセーブロード時にはロードも初期化もされません。
この性質のため、異なるセーブデータ間でのデータの共有に使うことができます。
GLOBALとSAVEDATAキーワードを同時に使用した場合、SAVEGLOBAL,LOADGLOBAL命令によってglobal.savファイルに読み書きされる変数となります。

その他、初期値や定数化などの詳細はユーザー定義の変数を参照してください。
マクロの定義¶

ここでいうマクロとはERBコード中の文字列を、あらかじめ定義した別の文字列へ置換する機能です。
マクロと名前は付いていますがEmueraの実行中にF1～F12キーで使えるキーボードマクロとは関係ありません。
この機能はCやC++の#defineを参考に作られています。
ERHファイル中でマクロを定義することで全てのERBファイル内のコードに適用されます。
基本的な使い方¶

マクロは典型的には以下のように定義します。

<*.ERH>  
    #DEFINE <置換元識別子> <置換先式>

これでERB中で<置換元識別子>が<置換先式>に置換されます。 例えば、.ERH中で

<*.ERH>  
    #DEFINE FIVE 5

と定義しておくと、.ERB中のFIVEという文字列が5に置換されます。 例えば

<*.ERB>  
    X = FIVE

は

(展開後)  
    X = 5

と展開されます。

マクロには行末コメントをつけることもできます。
セミコロン以降はコメントとして無視されます。
セミコロン以降はマクロに含まれず、展開されることはありません。

<*.ERH>  
    #DEFINE FIVE 5 ;コメント  
<*.ERB>  
    X = FIVE + FIVE  
(展開後)  
    X = 5 + 5

マクロの展開はほぼ文字列そのままで行われることに注意してください。

<*.ERH>  
    #DEFINE SIX           1 + 5  
    #DEFINE NINE          8 + 1  
<*.ERB>  
    X = SIX * NINE

はXに6*9、すなわち36が代入されると思うかもしれませんが、実際には

(展開後)  
    X = 1 + 5 * 8 + 1

と展開されるので掛け算が優先されてX = 42になります。

マクロは"～～"など定数文字列にも展開できますし、変数や関数、式にもできます。
#DEFINEの右側の文字列がそのまま展開されると考えればだいたいのところは理解できるでしょう。

<*.ERH>  
    #DEFINE HOGE        "ほげほげ"  
    #DEFINE PIYO        A  
    #DEFINE FUGA        DA:10  
    #DEFINE HOGERA      LOCAL + MY_FUNC(X, Y)  
<*.ERB>  
    X = STRLEN(HOGE)  
    Y = PIYO + 5  
    FUGA:20 += PIYO  
    LOCAL = HOGERA

    @MY_FUNC(ARG, ARG:1)  
    #FUNCTION  
        ～略～  
(展開後)  
    X = STRLEN("ほげほげ")  
    Y = A + 5  
    DA:10:20 += A  
    LOCAL = LOCAL + MY_FUNC(X, Y)

    @MY_FUNC(ARG, ARG:1)  
    #FUNCTION  
        ～略～

マクロは文字列そのままで展開されるという仕様上、置換先を完結した式ではなく演算子や式の一部とすることもできます。
ただしこのような使い方は推奨しません。
よほど慎重に使わないとコードの可読性を著しく損ねることになります。

<*.ERH>  
    #DEFINE PLUS       +  
    #DEFINE FIVEPLUS   5 +  
<*.ERB>  
    X = 1 PLUS 2  
    Y = FIVEPLUS 2  
(展開後)  
    X = 1 + 2  
    Y = 5 + 2

マクロの多重展開¶

マクロを含むマクロを定義することができます。 そのようなマクロはERBのロード時にマクロが適用できなくなるまで多重展開されます。

<.ERH>  
    #DEFINE FIVE_1 5  
    #DEFINE FIVE_2 FIVE_1 + FIVE_1  
    #DEFINE FIVE_3 FIVE_2 + FIVE_2  
<.ERB>  
    X = FIVE_3  
(展開後)  
    X = 5 + 5 + 5 + 5

展開を一定回数繰り返してもマクロが残っている場合、Emueraは自己参照又は循環参照マクロの疑いありとして処理を打ち切り、エラー終了します。
以下のような自己参照又は循環参照するマクロを作ってしまわないように気をつけてください。

<.ERH>  
    #DEFINE HOGE HOGE  
    #DEFINE PIYO FUGA + 1  
    #DEFINE FUGA PIYO + 2  
<.ERB>  
;エラーになる  
    X = HOGE  
    Y = PIYO

プリプロセッサ¶

ある名称のマクロが定義されているかどうかによって複数の行を実行するかどうか、分岐することができます。
[IF XXX]行と[ENDIF]行の間の行はXXXがDEFINEされている場合のみ実行されます。 例えば以下のように使います

<*.ERB>  
    [IF HOGE]  
        PRINTL HOGEが定義されている  
    [ELSEIF PUYO]  
        PRINTL HOGEが定義されていない  
        PRINTL PUYOが定義されている  
    [ELSE]  
        PRINTL HOGEもPUYOも定義されていない  
    [ENDIF]

この目的のため、空のマクロ（置換先のないマクロ）も定義できます。

<*.ERH>  
    #DEFINE HOGE

同じ用途でEM+EEのISDEFINEDを使用することもできます
マクロの制限¶

マクロが展開されるのは基本的に式中のみです。

<*.ERH>  
    #DEFINE FIVE 5  
<*.ERB>  
    PRINT FIVE

は単にFIVEの文字がPRINTされるだけです。
これはPRINT XがXの値ではなくXという文字をPRINTするだけなのと同じです。

マクロの置換先は代入演算子及び、代入演算子を含む式にすることはできません。
以下のマクロ定義はエラーになります。

<*.ERH>  
;エラーになる  
    #DEFINE HOGE =  
    #DEFINE PUGE X = 1

マクロの置換先は式の部分でも可能だと書きましたが、括弧の対応だけはマクロの中で完結している必要があります。 以下のマクロ定義はエラーになります。

<*.ERH>  
;エラーになる  
    #DEFINE HOGE ( X +  
    #DEFINE PUGE Y )  
<*.ERB>  
    Z = HOGE PUGE

マクロの置換先を命令にすることはできません。
以下のマクロ定義はエラーになります。

<*.ERH>  
    #DEFINE MY_PRINTL     PRINTL  
<*.ERB>  
    MY_PRINTL これはPRINTLです  
(展開後)  
    ;エラーになる

前記の通り、マクロは*.ERBにのみ適用され、*.csvと*.ERHには適用されません。
また*.ERB内でもプリプロセッサ、属性名、及び行頭の記号には適用されません。
[SKIPSTART]など、#DIMや#FUNCTIONなど、@EVENTFIRSTなどの@の部分、は置換対象外です。
例えば#DEFINE HOGE SKIPSTARTとしても、[HOGE]でコメント化開始とはなりません。
ただし、#以降の文字列であっても#DIMの変数名などは置換対象になります。
例えば下記のコードは

<*.ERH>  
    #DEFINE HOGE MY_INT  
    #DEFINE FIVE 5  
<*.ERB>  
    @FUNC  
    #DIM HOGE, FIVE  
    HOGE:0 = 10  
(展開後)  
    @FUNC  
    #DIM MY_INT, 5  
    MY_INT:0 = 10

のように展開されるので正常に動作します。


evilmask.gitlab.io
HTML_PRINT関連 - Emuera.EM+EE ドキュメント
5–7 分

ここではHTML_PRINT命令を始めとするhtml関連命令を解説します。
関連命令を使うことにより、htmlと類似した文法で表示内容を指定できます。
※EM+EEで仕様追加があったため、EM+EE準拠に改訂しています
HTML_PRINT¶

htmlっぽいタグを利用してPRINTする命令です。
引数がPRINTのような文字列ではなくPRINTSと同じ文字列式であり、自動的に改行するので実際はPRINTSLの動作に近いです。
HTML_PRINTによる描画はALIGNMENT、SETFONT、COLOR、FONTSTYLE命令とその類似命令の影響を受けません。
これらの効果を得るには全てタグで指定する必要があります。
<タグ名 属性='属性値'>テキスト<!--タグ名-->という形で使用します。
属性値は'～'または"～"で囲う必要があります。
Emueraにおける文字列との区別のために、'～'で囲うことを推奨します。

EM+EEの追加機能で、第二引数が0（デフォルト）以外の場合，強制改行をしなくなります。
p¶

<p align='～'>テキスト</p>

pタグは文字列の前にのみ置くことができ、</p>は最後にのみ置くことができます。
</p>は省略してもかまいません。

    align属性
    必須
    ALIGNMENT命令に相当します。left, center, rightの三種が指定できます。

nobr¶

<nobr>テキスト</nobr>

PRINTSINGLE命令による描画に相当します
このタグをつけると描画領域を越えたことによる暗黙の改行が行われなくなります（<br>による明示の改行は可能です）
ただしEmueraはブラウザと違って横方向にスクロールできないのでウインドウ幅を越えた分は見えなくなります。
<nobr>は最初のテキストより前にのみ置くことができ、</nobr>は最後のテキストより後のみ置くことができます。
</nobr>は省略しても構いません
br¶

改行します。
この効果は表示行の改行なのでいくつ<br>があってもCLEARLINEやLINECOUTでは一行とみなされます。
button, nonbutton¶

<button value='～' title='～' pos='～'>テキスト</button>  
<nonbutton title='～' pos='～'>テキスト</nonbutton>

buttonは囲った部分のテキストをクリック可能なボタンにします。
nonbuttonは囲った部分のテキストをボタンでないテキストとして表示します。

    value属性
    buttonにのみ指定できます。
    valueを省略した場合、クリック不可の<nonbutton>と同様の非ボタンになります。

    title属性
    ボタンをポイントしたときに表示されるツールチップの表示内容を指定します。

    pos属性
    alignがleftかつnobrタグが使用されている場合にのみ使用できます。
    画面左端からの位置をフォントサイズに対する％で指定します。
    例えば<button pos='300'>ボタン</button>ならば「　　　ボタン」とほぼ同じ位置にボタンが書かれます。

font¶

<font face='～' color='～' bcolor='～'>テキスト</font>

囲った部分のフォント、表示色、ボタンの選択中表示色、を変更します
このタグは入れ子にすることができます

    face属性
    フォント名を指定します。空文字列を指定した場合、コンフィグで指定されたフォントになります。
    指定されたフォントが存在しないかサポートされない場合、「Microsoft Sans Serif」が代わりに使用されます。
    （これは .Net FrameworkのSystem.Drawing.Fontクラスの仕様によります）

    color属性
    テキストの表示色を指定します。
    色指定は#FF0080のような16進数形式かred、blueのような単語形式で指定します。
    色名は.Net FrameworkのColor構造体の定義色に準じます。
    ただしTransparentは色名として指定できません。

    bcolor属性
    ボタンの選択中表示色を指定します。

b, i, u, s¶

<b>太字</b>, <i>イタリック</i>, <u>アンダーライン</u>, <s>打消し線</s>

囲った部分の文字をそれぞれ太字、イタリック、アンダーライン付、打消し線付にします
img¶

<img src='～～' srcb='～～' height='～～'>

行内に画像を表示します。
画像を準備する方法はリソース設定を参照してください。

    src属性
    必須
    resourcesフォルダのcsvで作成したリソース名を指定します
    heightやwidthを指定しない場合、縦横比を維持したまま、縦幅がフォントサイズと一致するように縮小又は拡大して表示されます。
    描画インターフェイスがWINAPIの場合、アルファブレンドは行われません。

    srcb属性
    resourcesフォルダのcsvで作成したリソース名を指定します
    srcbにはボタン選択時に表示されるべきリソース名を指定します。
    省略した場合srcと同一画像が使われます。
    画像はsrcと同じサイズに縮小又は拡大して表示されます。

    height属性
    表示サイズの縦幅をフォントサイズに対する％で指定します。省略すると100です。
    負の値を指定した場合、画像を縦に反転して表示します。

    width属性
    表示サイズの横幅をフォントサイズに対する％で指定します。省略すると0です。
    0の場合、元画像の縦横比を維持する値になります。
    負の値を指定した場合、画像を横に反転して表示します。

    ypos属性
    表示位置の縦軸位置をフォントサイズに対する％で指定します。省略すると0です。
    「行の高さ」ではなく「フォントサイズ」が基準であることに注意してください。
    横軸位置の調整には<shape type='space'>やbuttonのpos属性を利用してください。

    px表記 上記の属性に関しては数値の後にpxを付けることでpx指定が可能

    srcm属性 CBG系のボタンマップと似ています。INPUT系の拡張モードまたはINPUTMOUSEKEY命令を実行するとき，マウスカーソル直下のボタンマップ画像の色（RGB部分）をRESULT:3(INPUTMOUSEKEYの場合RESULT:6)に代入します。

shape¶

<shape type='rect' param='～～' color='～～' bcolor='～～'>  
<shape type='space' param='～～'>

行中に指定した図形を描画します。

    type属性
    必須
    描画する図形のタイプを指定します。
    rect又はspaceが使用可能です。
        type='rect'
        長方形を描画します。
        paramには1又は4つの数字を指定します。
        paramが1つのとき長方形の横幅を指定します。
        <shape type='rect' param='400'>は横幅がフォントサイズの400%である長方形を描画します。
        paramが4つのときx,y,横幅,縦幅順で指定します。
        <shape type='rect' param='0,25,400,50'>は行の上下中央に縦幅がフォントサイズの50%の長方形を描画します。
        param='400'はparam='0,0,400,100'と同じ意味になります。
        type='space'
        paramに指定した幅だけ何も表示しません。
        例えば<shape type='space' param='400'>はフォントサイズの400%の区間だけ何も描画しません。
        これは全角スペース4つ分とおおよそ同じです。

    param属性
    必須
    図形描画のためのパラメータをフォントサイズとの比率(百分率)で指定します。
    複数の値を指定する場合はカンマで区切ります。

    color属性
    図形の色を指定します。指定のフォーマットは<font>タグと同じです。

    bcolor属性
    図形のボタン選択中の色を指定します。指定のフォーマットは<font>タグと同じです。

clearbutton¶

EM+EEで追加された機能です。<clearbutton>は囲った部分のボタンかを無効とする（title、pos属性の機能は残る）

    属性notooltipがtrueの場合、ボタンtitle属性も無効とすいる

div¶

EM+EEで追加された機能です。<div>で囲った内容を指定したエリアで表示することが可能です。<div>は入れ子構造に対応していません。他のタグと併用可能です。

    width属性：サブエリアの幅。<img>、<shape>タグのようにpx、フォントサイズとの百分率で指定可能。
    height属性：サブエリアの高さ。<img>、<shape>タグのようにpx、フォントサイズとの百分率で指定可能。
    xpos属性：サブエリアが現在位置からの横方向距離。省略可。負数なら左寄り，正数なら右寄り。<img>、<shape>タグのようにpx、フォントサイズとの百分率で指定可能。
    ypos属性：サブエリアが現在位置からの縦方向距離。省略可。負数なら上寄り，正数なら下寄り。<img>、<shape>タグのようにpx、フォントサイズとの百分率で指定可能。
    size属性：widthとheightの簡略化です。書式：size='width,height'。
    rect属性：xpos、ypos、widthとheightの簡略化です。書式：rect='xpos,ypos,width,height'。
    depth属性：サブエリアの奥行き。省略可。負数なら手前に，正数なら奥に。

    color属性：サブエリアの背景色。省略可。指定のフォーマットは<font>タグのcolor属性と同じです。

    display属性：サブエリアの描画形式。省略可。
        relative（デフォルト）：今の文字位置で描画。
        absolute：ウィンドウの固定位置で描画、スクロールしても移動しません。(0, 0)はウィンドウの左下、yposは上方向が正です。

    margin属性：サブエリアの全四辺のマージン領域。省略可。
        margin='all'：allを四辺すべてに適用します。px、フォントサイズ百分率両方可。
        margin='leftRight,topBottom'：leftRightを上下、leftRightを左右に適用します。px、フォントサイズ百分率両方可。
        margin='top,leftRight,bottom'：topを上、leftRightを左右、bottomを下に適用します。px、フォントサイズ百分率両方可。
        margin='top,right,bottom,left'：topを上、rightを右、bottomを下、leftを左に適用します。px、フォントサイズ百分率両方可。

    padding属性：サブエリアの全四辺のパディング領域。省略可。指定のフォーマットはmargin属性と同じです。
    border属性：サブエリアの境界の幅。省略可。指定のフォーマットはmargin属性と同じです。

    bcolor属性：サブエリアの境界の色。省略可。指定のフォーマットはmargin属性と似ているが、色の書式は<font>タグのcolor属性と同じです。

    radius属性：サブエリアの境界の外側の角の丸め（半径）。省略可。
        radius='all'：allを全四角に適用します。px、フォントサイズ百分率両方可。
        radius='ltRb,rtLb'：ltRbを左上と右下、rtLb右上と左下に適用します。px、フォントサイズ百分率両方可。
        radius='lt,rtLb,rb'：ltを左上、rtLbを右上と左下、rbを右下に適用します。px、フォントサイズ百分率両方可。
        radius='lt,rt,rb,lb'：ltを左上、rtを右上、rbを右下、lbを左下に適用します。px、フォントサイズ百分率両方可。

文字参照¶

&と;で囲まれた単語があるとそれを文字参照として処理します。
対応している文字参照は&amp;, &gt;, &lt;, &quot;, &apos;及び&#nn;, &#xnn;です。
コメント¶

<!-- コメント -->

html解釈にあたり、<!--及び-->で囲われた文字は無視されます
関連命令・関数¶

リファレンス内にあるHTML系の項目を参照してください


evilmask.gitlab.io
リソースファイル - Emuera.EM+EE ドキュメント
~3 分
リソースファイル¶

ここではEmueraで画像を表示するためのリソースファイルの準備方法を解説します。

リソースファイルは実行ファイルのあるフォルダにresourcesフォルダを作成しその中に置きます。
ファイルはresourcesフォルダ内であればサブフォルダにおいてもかまいません（1.823以降）。
リソース指定ファイル(csv)¶

resourcesフォルダにcsv形式のテキストを置くとリソース指定ファイルとして読み込まれます。 書式は以下の通りです。

;コメント行  
リソース名A, 元ファイル名, x, y, width, height, posx, posy  
リソース名B, 元ファイル名, x, y, width, height, posx, posy

リソース名C, ANIME, width, height  
リソース名C, 元ファイル名, x, y, width, height, posx, posy, delay  
リソース名C, 元ファイル名, x, y, width, height, posx, posy, delay

    コメント行
    セミコロンで始まる行はコメント行として無視されます。

    スプライト

    リソース名A, 元ファイル名, x, y, width, height, posx, posy

    上記の形式によりリソース名Aを持つスプライトを作成できます。
    リソース名は<img src='リソース名A'>のsrc属性の属性値として使用される名前です。
    また、SPRITECREATED("リソース名A")のような形でも使用されます。
    リソース名は他のリソースの名前と重複してはいけません。
    元ファイル名は画像ファイルの名前です。拡張子を含めて指定します。csvファイルからみた相対パスで指定します。
    csvファイルよりも上位の階層にある画像ファイルを指定することはできません。
    csvファイルと同一かそのサブフォルダにある画像ファイルを指定してください。
    x, y, width, heightには元画像の中の使用する部分をピクセル単位で指定します。
    x, y, width, heightは省略することもでき、その場合は画像全体が使用されます。
    posx, posyには画像の相対位置を指定します。この値はSPRITEPOSやSPRITEMOVE命令によって動的に変更できます。
    posx, posyは省略することもでき、その場合は0,0を指定したことになります。

    アニメーションスプライト

    リソース名C, ANIME, width, height  
    リソース名C, 元ファイル名, x, y, width, height, offsetx, offsety, delay  
    リソース名C, 元ファイル名, x, y, width, height, offsetx, offsety, delay  
    ……

    上記の形式によりリソース名Cを持つアニメーションスプライトを作成できます。
    アニメーションスプライトを作成するには、ファイル名の代わりにANIMEと記載した行を作り、スプライト全体のサイズを指定します。
    このwidth, heightは正の整数でなければなりません。省略することはできません。
    次の行以降に、アニメーションの各フレームとなる画像を指定します。
    各フレームの定義の仕方は通常スプライトと同じです。
    delayにはそのフレームが表示される時間をミリ秒単位で指定します。省略した場合1000msになります。
    注意点として、Emueraは標準ではINPUT等の待機時間に再描画を行わないため、アニメーションスプライトは特定のフレームで静止しているように見えます。
    SETANIMETIMER命令を実行してINPUT中に再描画を行うように指示して下さい。
    SETANIMETIMER命令の詳細は命令の解説を参照してください。

画像ファイル¶

画像の表示のためには画像ファイルが必要です。
画像ファイルはbmp、jpg、png形式の何れかで用意しresourcesフォルダ内に置きます。
EM+EEではライブラリを同梱することでwebp形式も使用できます
ERB内ではGCREATEFROMFILEを使用することでグラフィックを生成することもできます
注意点¶

csvファイルで指定された全ての画像ファイルはEmueraの起動時にメモリ上に展開され終了するまでメモリを占有します。
大量の画像ファイルを読ませるよりも画像を単一のファイルに合成し範囲を指定して利用した方がメモリ的にも速度的にも有利と思います。
また、必要な場合に適宜GCREATEFROMFILEとGDISPOSE、SPRITECREATEとSPRITEDISPOSEを行う処理も効果的です
コンフィグの描画インタフェースにWINAPIを指定している場合はGDIにより処理され、アルファブレンドは行われません。
描画インタフェースがGraphics又はTextRendererの場合にはGDI+により処理され、アルファブレンドが行われます。
拡大縮小もWINAPI(GDI)とGraphics又はTextRenderer(GDI+)`でやや異なります。
